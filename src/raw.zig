pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const __builtin_va_list = [*c]u8;
pub const __gnuc_va_list = __builtin_va_list;
pub const va_list = __gnuc_va_list;
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:610:3: warning: TODO implement translation of stmt class GCCAsmStmtClass

// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:605:36: warning: unable to translate function, demoted to extern
pub extern fn __debugbreak() void;
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:632:3: warning: TODO implement translation of stmt class GCCAsmStmtClass

// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:626:60: warning: unable to translate function, demoted to extern
pub extern fn __fastfail(arg_code: c_uint) noreturn;
pub extern fn __mingw_get_crt_info() [*c]const u8;
pub const rsize_t = usize;
pub const ptrdiff_t = c_longlong;
pub const wchar_t = c_ushort;
pub const wint_t = c_ushort;
pub const wctype_t = c_ushort;
pub const errno_t = c_int;
pub const __time32_t = c_long;
pub const __time64_t = c_longlong;
pub const time_t = __time64_t;
pub const struct_threadlocaleinfostruct = extern struct {
    _locale_pctype: [*c]const c_ushort = @import("std").mem.zeroes([*c]const c_ushort),
    _locale_mb_cur_max: c_int = @import("std").mem.zeroes(c_int),
    _locale_lc_codepage: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_threadmbcinfostruct = opaque {};
pub const pthreadlocinfo = [*c]struct_threadlocaleinfostruct;
pub const pthreadmbcinfo = ?*struct_threadmbcinfostruct;
pub const struct___lc_time_data = opaque {};
pub const struct_localeinfo_struct = extern struct {
    locinfo: pthreadlocinfo = @import("std").mem.zeroes(pthreadlocinfo),
    mbcinfo: pthreadmbcinfo = @import("std").mem.zeroes(pthreadmbcinfo),
};
pub const _locale_tstruct = struct_localeinfo_struct;
pub const _locale_t = [*c]struct_localeinfo_struct;
pub const struct_tagLC_ID = extern struct {
    wLanguage: c_ushort = @import("std").mem.zeroes(c_ushort),
    wCountry: c_ushort = @import("std").mem.zeroes(c_ushort),
    wCodePage: c_ushort = @import("std").mem.zeroes(c_ushort),
};
pub const LC_ID = struct_tagLC_ID;
pub const LPLC_ID = [*c]struct_tagLC_ID;
pub const threadlocinfo = struct_threadlocaleinfostruct;
pub extern fn _wassert(_Message: [*c]const wchar_t, _File: [*c]const wchar_t, _Line: c_uint) noreturn;
pub extern fn _assert(_Message: [*c]const u8, _File: [*c]const u8, _Line: c_uint) noreturn;
pub const max_align_t = extern struct {
    __clang_max_align_nonce1: c_longlong align(8) = @import("std").mem.zeroes(c_longlong),
    __clang_max_align_nonce2: c_longdouble align(16) = @import("std").mem.zeroes(c_longdouble),
};
pub const int_least8_t = i8;
pub const uint_least8_t = u8;
pub const int_least16_t = c_short;
pub const uint_least16_t = c_ushort;
pub const int_least32_t = c_int;
pub const uint_least32_t = c_uint;
pub const int_least64_t = c_longlong;
pub const uint_least64_t = c_ulonglong;
pub const int_fast8_t = i8;
pub const uint_fast8_t = u8;
pub const int_fast16_t = c_short;
pub const uint_fast16_t = c_ushort;
pub const int_fast32_t = c_int;
pub const uint_fast32_t = c_uint;
pub const int_fast64_t = c_longlong;
pub const uint_fast64_t = c_ulonglong;
pub const intmax_t = c_longlong;
pub const uintmax_t = c_ulonglong;
pub const struct__exception = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    arg1: f64 = @import("std").mem.zeroes(f64),
    arg2: f64 = @import("std").mem.zeroes(f64),
    retval: f64 = @import("std").mem.zeroes(f64),
};
const struct_unnamed_1 = extern struct {
    low: c_uint = @import("std").mem.zeroes(c_uint),
    high: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const union___mingw_dbl_type_t = extern union {
    x: f64,
    val: c_ulonglong,
    lh: struct_unnamed_1,
};
pub const __mingw_dbl_type_t = union___mingw_dbl_type_t;
pub const union___mingw_flt_type_t = extern union {
    x: f32,
    val: c_uint,
};
pub const __mingw_flt_type_t = union___mingw_flt_type_t;
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:135:11: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_2 = opaque {};
pub const union___mingw_ldbl_type_t = extern union {
    x: c_longdouble,
    lh: struct_unnamed_2,
};
pub const __mingw_ldbl_type_t = union___mingw_ldbl_type_t;
pub extern var __imp__HUGE: [*c]f64;
pub extern fn __mingw_raise_matherr(typ: c_int, name: [*c]const u8, a1: f64, a2: f64, rslt: f64) void;
pub extern fn __mingw_setusermatherr(?*const fn ([*c]struct__exception) callconv(.c) c_int) void;
pub extern fn __setusermatherr(?*const fn ([*c]struct__exception) callconv(.c) c_int) void;
pub extern fn sin(_X: f64) f64;
pub extern fn cos(_X: f64) f64;
pub extern fn tan(_X: f64) f64;
pub extern fn sinh(_X: f64) f64;
pub extern fn cosh(_X: f64) f64;
pub extern fn tanh(_X: f64) f64;
pub extern fn asin(_X: f64) f64;
pub extern fn acos(_X: f64) f64;
pub extern fn atan(_X: f64) f64;
pub extern fn atan2(_Y: f64, _X: f64) f64;
pub extern fn exp(_X: f64) f64;
pub extern fn log(_X: f64) f64;
pub extern fn log10(_X: f64) f64;
pub extern fn pow(_X: f64, _Y: f64) f64;
pub extern fn sqrt(_X: f64) f64;
pub extern fn ceil(_X: f64) f64;
pub extern fn floor(_X: f64) f64;
pub extern fn fabsf(x: f32) f32;
pub extern fn fabsl(c_longdouble) c_longdouble;
pub extern fn fabs(_X: f64) f64;
pub extern fn ldexp(_X: f64, _Y: c_int) f64;
pub extern fn frexp(_X: f64, _Y: [*c]c_int) f64;
pub extern fn modf(_X: f64, _Y: [*c]f64) f64;
pub extern fn fmod(_X: f64, _Y: f64) f64;
pub extern fn sincos(__x: f64, p_sin: [*c]f64, p_cos: [*c]f64) void;
pub extern fn sincosl(__x: c_longdouble, p_sin: [*c]c_longdouble, p_cos: [*c]c_longdouble) void;
pub extern fn sincosf(__x: f32, p_sin: [*c]f32, p_cos: [*c]f32) void;
pub extern fn abs(_X: c_int) c_int;
pub extern fn labs(_X: c_long) c_long;
pub extern fn atof(_String: [*c]const u8) f64;
pub extern fn _atof_l(_String: [*c]const u8, _Locale: _locale_t) f64;
pub const struct__complex = extern struct {
    x: f64 = @import("std").mem.zeroes(f64),
    y: f64 = @import("std").mem.zeroes(f64),
};
pub extern fn _cabs(_ComplexA: struct__complex) f64;
pub extern fn _hypot(_X: f64, _Y: f64) f64;
pub extern fn _j0(_X: f64) f64;
pub extern fn _j1(_X: f64) f64;
pub extern fn _jn(_X: c_int, _Y: f64) f64;
pub extern fn _y0(_X: f64) f64;
pub extern fn _y1(_X: f64) f64;
pub extern fn _yn(_X: c_int, _Y: f64) f64;
pub extern fn _matherr([*c]struct__exception) c_int;
pub extern fn _chgsign(_X: f64) f64;
pub extern fn _copysign(_Number: f64, _Sign: f64) f64;
pub extern fn _logb(f64) f64;
pub extern fn _nextafter(f64, f64) f64;
pub extern fn _scalb(f64, c_long) f64;
pub extern fn _finite(f64) c_int;
pub extern fn _fpclass(f64) c_int;
pub extern fn _isnan(f64) c_int;
pub extern fn j0(f64) f64;
pub extern fn j1(f64) f64;
pub extern fn jn(c_int, f64) f64;
pub extern fn y0(f64) f64;
pub extern fn y1(f64) f64;
pub extern fn yn(c_int, f64) f64;
pub extern fn chgsign(f64) f64;
pub extern fn finite(f64) c_int;
pub extern fn fpclass(f64) c_int;
pub const float_t = f32;
pub const double_t = f64;
pub extern fn __fpclassifyl(c_longdouble) c_int;
pub extern fn __fpclassifyf(f32) c_int;
pub extern fn __fpclassify(f64) c_int;
pub extern fn __isnan(f64) c_int;
pub extern fn __isnanf(f32) c_int;
pub extern fn __isnanl(c_longdouble) c_int;
pub extern fn __signbit(f64) c_int;
pub extern fn __signbitf(f32) c_int;
pub extern fn __signbitl(c_longdouble) c_int;
pub extern fn sinf(_X: f32) f32;
pub extern fn sinl(c_longdouble) c_longdouble;
pub extern fn cosf(_X: f32) f32;
pub extern fn cosl(c_longdouble) c_longdouble;
pub extern fn tanf(_X: f32) f32;
pub extern fn tanl(c_longdouble) c_longdouble;
pub extern fn asinf(_X: f32) f32;
pub extern fn asinl(c_longdouble) c_longdouble;
pub extern fn acosf(f32) f32;
pub extern fn acosl(c_longdouble) c_longdouble;
pub extern fn atanf(f32) f32;
pub extern fn atanl(c_longdouble) c_longdouble;
pub extern fn atan2f(f32, f32) f32;
pub extern fn atan2l(c_longdouble, c_longdouble) c_longdouble;
pub extern fn sinhf(_X: f32) f32;
pub extern fn sinhl(c_longdouble) c_longdouble;
pub extern fn coshf(_X: f32) f32;
pub extern fn coshl(c_longdouble) c_longdouble;
pub extern fn tanhf(_X: f32) f32;
pub extern fn tanhl(c_longdouble) c_longdouble;
pub extern fn acosh(f64) f64;
pub extern fn acoshf(f32) f32;
pub extern fn acoshl(c_longdouble) c_longdouble;
pub extern fn asinh(f64) f64;
pub extern fn asinhf(f32) f32;
pub extern fn asinhl(c_longdouble) c_longdouble;
pub extern fn atanh(f64) f64;
pub extern fn atanhf(f32) f32;
pub extern fn atanhl(c_longdouble) c_longdouble;
pub extern fn expf(_X: f32) f32;
pub extern fn expl(c_longdouble) c_longdouble;
pub extern fn exp2(f64) f64;
pub extern fn exp2f(f32) f32;
pub extern fn exp2l(c_longdouble) c_longdouble;
pub extern fn expm1(f64) f64;
pub extern fn expm1f(f32) f32;
pub extern fn expm1l(c_longdouble) c_longdouble;
pub extern fn frexpf(_X: f32, _Y: [*c]c_int) f32;
pub extern fn frexpl(c_longdouble, [*c]c_int) c_longdouble;
pub extern fn ilogb(f64) c_int;
pub extern fn ilogbf(f32) c_int;
pub extern fn ilogbl(c_longdouble) c_int;
pub extern fn ldexpf(_X: f32, _Y: c_int) f32;
pub extern fn ldexpl(c_longdouble, c_int) c_longdouble;
pub extern fn logf(f32) f32;
pub extern fn logl(c_longdouble) c_longdouble;
pub extern fn log10f(f32) f32;
pub extern fn log10l(c_longdouble) c_longdouble;
pub extern fn log1p(f64) f64;
pub extern fn log1pf(f32) f32;
pub extern fn log1pl(c_longdouble) c_longdouble;
pub extern fn log2(f64) f64;
pub extern fn log2f(f32) f32;
pub extern fn log2l(c_longdouble) c_longdouble;
pub extern fn logb(f64) f64;
pub extern fn logbf(f32) f32;
pub extern fn logbl(c_longdouble) c_longdouble;
pub extern fn modff(f32, [*c]f32) f32;
pub extern fn modfl(c_longdouble, [*c]c_longdouble) c_longdouble;
pub extern fn scalbn(f64, c_int) f64;
pub extern fn scalbnf(f32, c_int) f32;
pub extern fn scalbnl(c_longdouble, c_int) c_longdouble;
pub extern fn scalbln(f64, c_long) f64;
pub extern fn scalblnf(f32, c_long) f32;
pub extern fn scalblnl(c_longdouble, c_long) c_longdouble;
pub extern fn cbrt(f64) f64;
pub extern fn cbrtf(f32) f32;
pub extern fn cbrtl(c_longdouble) c_longdouble;
pub extern fn hypot(f64, f64) f64;
pub extern fn hypotf(x: f32, y: f32) f32;
pub extern fn hypotl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn powf(_X: f32, _Y: f32) f32;
pub extern fn powl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn sqrtf(f32) f32;
pub extern fn sqrtl(c_longdouble) c_longdouble;
pub extern fn erf(f64) f64;
pub extern fn erff(f32) f32;
pub extern fn erfl(c_longdouble) c_longdouble;
pub extern fn erfc(f64) f64;
pub extern fn erfcf(f32) f32;
pub extern fn erfcl(c_longdouble) c_longdouble;
pub extern fn lgamma(f64) f64;
pub extern fn lgammaf(f32) f32;
pub extern fn lgammal(c_longdouble) c_longdouble;
pub extern var signgam: c_int;
pub extern fn tgamma(f64) f64;
pub extern fn tgammaf(f32) f32;
pub extern fn tgammal(c_longdouble) c_longdouble;
pub extern fn ceilf(f32) f32;
pub extern fn ceill(c_longdouble) c_longdouble;
pub extern fn floorf(f32) f32;
pub extern fn floorl(c_longdouble) c_longdouble;
pub extern fn nearbyint(f64) f64;
pub extern fn nearbyintf(f32) f32;
pub extern fn nearbyintl(c_longdouble) c_longdouble;
pub extern fn rint(f64) f64;
pub extern fn rintf(f32) f32;
pub extern fn rintl(c_longdouble) c_longdouble;
pub extern fn lrint(f64) c_long;
pub extern fn lrintf(f32) c_long;
pub extern fn lrintl(c_longdouble) c_long;
pub extern fn llrint(f64) c_longlong;
pub extern fn llrintf(f32) c_longlong;
pub extern fn llrintl(c_longdouble) c_longlong;
pub extern fn round(f64) f64;
pub extern fn roundf(f32) f32;
pub extern fn roundl(c_longdouble) c_longdouble;
pub extern fn lround(f64) c_long;
pub extern fn lroundf(f32) c_long;
pub extern fn lroundl(c_longdouble) c_long;
pub extern fn llround(f64) c_longlong;
pub extern fn llroundf(f32) c_longlong;
pub extern fn llroundl(c_longdouble) c_longlong;
pub extern fn trunc(f64) f64;
pub extern fn truncf(f32) f32;
pub extern fn truncl(c_longdouble) c_longdouble;
pub extern fn fmodf(f32, f32) f32;
pub extern fn fmodl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn remainder(f64, f64) f64;
pub extern fn remainderf(f32, f32) f32;
pub extern fn remainderl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn remquo(f64, f64, [*c]c_int) f64;
pub extern fn remquof(f32, f32, [*c]c_int) f32;
pub extern fn remquol(c_longdouble, c_longdouble, [*c]c_int) c_longdouble;
pub extern fn copysign(f64, f64) f64;
pub extern fn copysignf(f32, f32) f32;
pub extern fn copysignl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn nan(tagp: [*c]const u8) f64;
pub extern fn nanf(tagp: [*c]const u8) f32;
pub extern fn nanl(tagp: [*c]const u8) c_longdouble;
pub extern fn nextafter(f64, f64) f64;
pub extern fn nextafterf(f32, f32) f32;
pub extern fn nextafterl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn nexttoward(f64, c_longdouble) f64;
pub extern fn nexttowardf(f32, c_longdouble) f32;
pub extern fn nexttowardl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn fdim(x: f64, y: f64) f64;
pub extern fn fdimf(x: f32, y: f32) f32;
pub extern fn fdiml(x: c_longdouble, y: c_longdouble) c_longdouble;
pub extern fn fmax(f64, f64) f64;
pub extern fn fmaxf(f32, f32) f32;
pub extern fn fmaxl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn fmin(f64, f64) f64;
pub extern fn fminf(f32, f32) f32;
pub extern fn fminl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn fma(f64, f64, f64) f64;
pub extern fn fmaf(f32, f32, f32) f32;
pub extern fn fmal(c_longdouble, c_longdouble, c_longdouble) c_longdouble;
pub extern fn _copysignf(_Number: f32, _Sign: f32) f32;
pub extern fn _chgsignf(_X: f32) f32;
pub extern fn _logbf(_X: f32) f32;
pub extern fn _nextafterf(_X: f32, _Y: f32) f32;
pub extern fn _finitef(_X: f32) c_int;
pub extern fn _isnanf(_X: f32) c_int;
pub extern fn _fpclassf(_X: f32) c_int;
pub extern fn _chgsignl(c_longdouble) c_longdouble;
pub const SKB_ALIGN_START: c_int = 0;
pub const SKB_ALIGN_CENTER: c_int = 1;
pub const SKB_ALIGN_END: c_int = 2;
pub const SKB_ALIGN_LEFT: c_int = 3;
pub const SKB_ALIGN_RIGHT: c_int = 4;
pub const SKB_ALIGN_TOP: c_int = 5;
pub const SKB_ALIGN_BOTTOM: c_int = 6;
pub const skb_align_t = c_uint;
pub const SKB_WRAP_NONE: c_int = 0;
pub const SKB_WRAP_WORD: c_int = 1;
pub const SKB_WRAP_WORD_CHAR: c_int = 2;
pub const skb_text_wrap_t = c_uint;
pub const SKB_OVERFLOW_NONE: c_int = 0;
pub const SKB_OVERFLOW_CLIP: c_int = 1;
pub const SKB_OVERFLOW_ELLIPSIS: c_int = 2;
pub const skb_text_overflow_t = c_uint;
pub const SKB_VERTICAL_TRIM_DEFAULT: c_int = 0;
pub const SKB_VERTICAL_TRIM_CAP_TO_BASELINE: c_int = 1;
pub const skb_vertical_trim_t = c_uint;
pub const SKB_LINE_HEIGHT_NORMAL: c_int = 0;
pub const SKB_LINE_HEIGHT_METRICS_RELATIVE: c_int = 1;
pub const SKB_LINE_HEIGHT_FONT_SIZE_RELATIVE: c_int = 2;
pub const SKB_LINE_HEIGHT_ABSOLUTE: c_int = 3;
pub const skb_line_height_t = c_uint;
pub const SKB_OBJECT_ALIGN_SELF: c_int = 0;
pub const SKB_OBJECT_ALIGN_TEXT_BEFORE: c_int = 1;
pub const SKB_OBJECT_ALIGN_TEXT_BEFORE_OR_AFTER: c_int = 2;
pub const SKB_OBJECT_ALIGN_TEXT_AFTER: c_int = 3;
pub const SKB_OBJECT_ALIGN_TEXT_AFTER_OR_BEFORE: c_int = 4;
pub const skb_object_align_reference_t = c_uint;
pub const SKB_DECORATION_STYLE_SOLID: c_int = 0;
pub const SKB_DECORATION_STYLE_DOUBLE: c_int = 1;
pub const SKB_DECORATION_STYLE_DOTTED: c_int = 2;
pub const SKB_DECORATION_STYLE_DASHED: c_int = 3;
pub const SKB_DECORATION_STYLE_WAVY: c_int = 4;
pub const skb_decoration_style_t = c_uint;
pub const SKB_DECORATION_UNDERLINE: c_int = 0;
pub const SKB_DECORATION_BOTTOMLINE: c_int = 1;
pub const SKB_DECORATION_OVERLINE: c_int = 2;
pub const SKB_DECORATION_THROUGHLINE: c_int = 3;
pub const skb_decoration_position_t = c_uint;
pub const SKB_AFFINITY_NONE: c_int = 0;
pub const SKB_AFFINITY_TRAILING: c_int = 1;
pub const SKB_AFFINITY_LEADING: c_int = 2;
pub const SKB_AFFINITY_SOL: c_int = 3;
pub const SKB_AFFINITY_EOL: c_int = 4;
pub const enum_skb_caret_affinity_t = c_uint;
pub const skb_caret_affinity_t = enum_skb_caret_affinity_t;
pub const struct_skb_text_position_t = extern struct {
    offset: i32 = @import("std").mem.zeroes(i32),
    affinity: skb_caret_affinity_t = @import("std").mem.zeroes(skb_caret_affinity_t),
};
pub const skb_text_position_t = struct_skb_text_position_t;
pub const struct_skb_text_selection_t = extern struct {
    start_pos: skb_text_position_t = @import("std").mem.zeroes(skb_text_position_t),
    end_pos: skb_text_position_t = @import("std").mem.zeroes(skb_text_position_t),
};
pub const skb_text_selection_t = struct_skb_text_selection_t;
pub const struct_skb_paragraph_position_t = extern struct {
    paragraph_idx: i32 = @import("std").mem.zeroes(i32),
    text_offset: i32 = @import("std").mem.zeroes(i32),
    global_text_offset: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_paragraph_position_t = struct_skb_paragraph_position_t;
pub const struct_skb_paragraph_range_t = extern struct {
    start_pos: skb_paragraph_position_t = @import("std").mem.zeroes(skb_paragraph_position_t),
    end_pos: skb_paragraph_position_t = @import("std").mem.zeroes(skb_paragraph_position_t),
};
pub const skb_paragraph_range_t = struct_skb_paragraph_range_t;
pub extern fn skb_debug_log(format: [*c]const u8, ...) void;
pub const SKB_INVALID_INDEX: c_int = -1;
const enum_unnamed_3 = c_int;
pub extern fn skb_malloc(size: usize) ?*anyopaque;
pub extern fn skb_realloc(ptr: ?*anyopaque, new_size: usize) ?*anyopaque;
pub extern fn skb_free(ptr: ?*anyopaque) void;
pub const skb_destroy_func_t = fn (?*anyopaque) callconv(.c) void;
pub fn skb_minf(arg_a: f32, arg_b: f32) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a < b) a else b;
}
pub fn skb_maxf(arg_a: f32, arg_b: f32) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a > b) a else b;
}
pub fn skb_absf(arg_a: f32) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    return if (a < 0.0) -a else a;
}
pub fn skb_clampf(arg_a: f32, arg_mn: f32, arg_mx: f32) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    var mn = arg_mn;
    _ = &mn;
    var mx = arg_mx;
    _ = &mx;
    return skb_minf(skb_maxf(a, mn), mx);
}
pub fn skb_lerpf(arg_a: f32, arg_b: f32, arg_t: f32) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var t = arg_t;
    _ = &t;
    return a + (t * (b - a));
}
pub fn skb_squaref(arg_x: f32) callconv(.c) f32 {
    var x = arg_x;
    _ = &x;
    return x * x;
}
pub fn skb_mini(arg_a: i32, arg_b: i32) callconv(.c) i32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a < b) a else b;
}
pub fn skb_maxi(arg_a: i32, arg_b: i32) callconv(.c) i32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a > b) a else b;
}
pub fn skb_absi(arg_a: i32) callconv(.c) i32 {
    var a = arg_a;
    _ = &a;
    return if (a < @as(c_int, 0)) -a else a;
}
pub fn skb_clampi(arg_a: i32, arg_mn: i32, arg_mx: c_int) callconv(.c) i32 {
    var a = arg_a;
    _ = &a;
    var mn = arg_mn;
    _ = &mn;
    var mx = arg_mx;
    _ = &mx;
    return skb_mini(skb_maxi(a, mn), mx);
}
pub fn skb_minu(arg_a: u32, arg_b: u32) callconv(.c) u32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a < b) a else b;
}
pub fn skb_maxu(arg_a: u32, arg_b: u32) callconv(.c) u32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a > b) a else b;
}
pub fn skb_clampu(arg_a: u32, arg_mn: u32, arg_mx: u32) callconv(.c) u32 {
    var a = arg_a;
    _ = &a;
    var mn = arg_mn;
    _ = &mn;
    var mx = arg_mx;
    _ = &mx;
    return skb_minu(skb_maxu(a, mn), mx);
}
pub fn skb_mul255(arg_a: i32, arg_b: i32) callconv(.c) i32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    a *= b;
    a += @as(i32, @bitCast(@as(c_int, 128)));
    a += a >> @intCast(8);
    return a >> @intCast(8);
}
pub fn skb_align(arg_v: i32, arg_align: i32) callconv(.c) c_int {
    var v = arg_v;
    _ = &v;
    var @"align" = arg_align;
    _ = &@"align";
    return ((v + @"align") - @as(c_int, 1)) & ~(@"align" - @as(c_int, 1));
}
pub fn skb_swapf(arg_a: [*c]f32, arg_b: [*c]f32) callconv(.c) void {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var tmp: f32 = a.*;
    _ = &tmp;
    a.* = b.*;
    b.* = tmp;
}
pub fn skb_swapi(arg_a: [*c]i32, arg_b: [*c]i32) callconv(.c) void {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var tmp: i32 = a.*;
    _ = &tmp;
    a.* = b.*;
    b.* = tmp;
}
pub fn skb_next_pow2(arg_v: i32) callconv(.c) i32 {
    var v = arg_v;
    _ = &v;
    _ = !!((v >= @as(c_int, 0)) and (v < @as(c_int, 1073741824))) or ((blk: {
        _assert("v >= 0 && v < 0x40000000", ".\\zig-out\\include/skb_common.h", @as(c_uint, @bitCast(@as(c_int, 293))));
        break :blk @as(c_int, 0);
    }) != 0);
    if (v == @as(c_int, 0)) return 1;
    v -= 1;
    v |= v >> @intCast(1);
    v |= v >> @intCast(2);
    v |= v >> @intCast(4);
    v |= v >> @intCast(8);
    v |= v >> @intCast(16);
    v += 1;
    return v;
}
pub fn skb_equalsf(arg_lhs: f32, arg_rhs: f32, arg_eps: f32) callconv(.c) bool {
    var lhs = arg_lhs;
    _ = &lhs;
    var rhs = arg_rhs;
    _ = &rhs;
    var eps = arg_eps;
    _ = &eps;
    return skb_absf(lhs - rhs) < eps;
}
pub const struct_skb_range_t = extern struct {
    start: i32 = @import("std").mem.zeroes(i32),
    end: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_range_t = struct_skb_range_t;
pub fn skb_range_overlap(arg_a: skb_range_t, arg_b: skb_range_t) callconv(.c) bool {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return skb_maxi(a.start, b.start) < skb_mini(a.end, b.end);
}
pub fn skb_range_contains(arg_r: skb_range_t, arg_idx: i32) callconv(.c) bool {
    var r = arg_r;
    _ = &r;
    var idx = arg_idx;
    _ = &idx;
    return (idx >= r.start) and (idx < r.end);
}
pub fn skb_range_is_empty(arg_r: skb_range_t) callconv(.c) bool {
    var r = arg_r;
    _ = &r;
    return r.start >= r.end;
}
pub const struct_skb_color_t = extern struct {
    r: u8 = @import("std").mem.zeroes(u8),
    g: u8 = @import("std").mem.zeroes(u8),
    b: u8 = @import("std").mem.zeroes(u8),
    a: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_color_t = struct_skb_color_t;
pub fn skb_rgba(arg_r: u8, arg_g: u8, arg_b: u8, arg_a: u8) callconv(.c) skb_color_t {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var a = arg_a;
    _ = &a;
    var res: skb_color_t = undefined;
    _ = &res;
    res.r = r;
    res.g = g;
    res.b = b;
    res.a = a;
    return res;
}
pub fn skb_color_equals(arg_lhs: skb_color_t, arg_rhs: skb_color_t) callconv(.c) bool {
    var lhs = arg_lhs;
    _ = &lhs;
    var rhs = arg_rhs;
    _ = &rhs;
    const u: u32 = @as([*c]u32, @ptrCast(@alignCast(&lhs))).*;
    _ = &u;
    const v: u32 = @as([*c]u32, @ptrCast(@alignCast(&rhs))).*;
    _ = &v;
    return u == v;
}
pub fn skb_color_mul_alpha(arg_col: skb_color_t, arg_alpha: u8) callconv(.c) skb_color_t {
    var col = arg_col;
    _ = &col;
    var alpha = arg_alpha;
    _ = &alpha;
    const u: u32 = @as([*c]u32, @ptrCast(@alignCast(&col))).*;
    _ = &u;
    var rb: u32 = u & @as(u32, @bitCast(@as(c_int, 16711935)));
    _ = &rb;
    rb *%= @as(u32, @bitCast(@as(c_uint, alpha)));
    rb +%= @as(u32, @bitCast(@as(c_int, 8388736)));
    rb +%= (rb >> @intCast(8)) & @as(u32, @bitCast(@as(c_int, 16711935)));
    rb &= @as(u32, @bitCast(@as(c_uint, 4278255360)));
    var ga: u32 = (u >> @intCast(8)) & @as(u32, @bitCast(@as(c_int, 16711935)));
    _ = &ga;
    ga *%= @as(u32, @bitCast(@as(c_uint, alpha)));
    ga +%= @as(u32, @bitCast(@as(c_int, 8388736)));
    ga +%= (ga >> @intCast(8)) & @as(u32, @bitCast(@as(c_int, 16711935)));
    ga &= @as(u32, @bitCast(@as(c_uint, 4278255360)));
    const r: u32 = ga | (rb >> @intCast(8));
    _ = &r;
    return @as([*c]const skb_color_t, @ptrCast(@alignCast(&r))).*;
}
pub fn skb_color_add(arg_a: skb_color_t, arg_b: skb_color_t) callconv(.c) skb_color_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    const au: u32 = @as([*c]u32, @ptrCast(@alignCast(&a))).*;
    _ = &au;
    const bu: u32 = @as([*c]u32, @ptrCast(@alignCast(&b))).*;
    _ = &bu;
    var rb: u32 = au & @as(u32, @bitCast(@as(c_int, 16711935)));
    _ = &rb;
    rb +%= bu & @as(u32, @bitCast(@as(c_int, 16711935)));
    rb &= @as(u32, @bitCast(@as(c_int, 16711935)));
    var ga: u32 = (au >> @intCast(8)) & @as(u32, @bitCast(@as(c_int, 16711935)));
    _ = &ga;
    ga +%= (bu >> @intCast(8)) & @as(u32, @bitCast(@as(c_int, 16711935)));
    ga &= @as(u32, @bitCast(@as(c_int, 16711935)));
    const r: u32 = (ga << @intCast(8)) | rb;
    _ = &r;
    return @as([*c]const skb_color_t, @ptrCast(@alignCast(&r))).*;
}
pub fn skb_color_average(arg_a: skb_color_t, arg_b: skb_color_t) callconv(.c) skb_color_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var au: u32 = @as([*c]u32, @ptrCast(@alignCast(&a))).*;
    _ = &au;
    var bu: u32 = @as([*c]u32, @ptrCast(@alignCast(&b))).*;
    _ = &bu;
    var acc: u32 = (au & @as(u32, @bitCast(@as(c_int, 16843009)))) +% (bu & @as(u32, @bitCast(@as(c_int, 16843009))));
    _ = &acc;
    au = (au >> @intCast(1)) & @as(u32, @bitCast(@as(c_int, 2139062143)));
    bu = (bu >> @intCast(1)) & @as(u32, @bitCast(@as(c_int, 2139062143)));
    acc = (acc >> @intCast(1)) & @as(u32, @bitCast(@as(c_int, 2139062143)));
    const r: u32 = (au +% bu) +% acc;
    _ = &r;
    return @as([*c]const skb_color_t, @ptrCast(@alignCast(&r))).*;
}
pub fn skb_color_lerp(arg_a: skb_color_t, arg_b: skb_color_t, arg_t: u8) callconv(.c) skb_color_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var t = arg_t;
    _ = &t;
    b = skb_color_mul_alpha(b, t);
    if (@as(c_int, @bitCast(@as(c_uint, b.a))) == @as(c_int, 255)) return b;
    if (@as(c_int, @bitCast(@as(c_uint, b.a))) == @as(c_int, 0)) return a;
    a = skb_color_mul_alpha(a, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 255) - @as(c_int, @bitCast(@as(c_uint, b.a))))))));
    return skb_color_add(a, b);
}
pub fn skb_color_lerpf(arg_a: skb_color_t, arg_b: skb_color_t, arg_t: f32) callconv(.c) skb_color_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var t = arg_t;
    _ = &t;
    const ti: i32 = @as(i32, @intFromFloat(t * 255.0));
    _ = &ti;
    return skb_color_lerp(a, b, @as(u8, @bitCast(@as(i8, @truncate(ti)))));
}
pub fn skb_color_blend(arg_dst: skb_color_t, arg_src: skb_color_t) callconv(.c) skb_color_t {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    dst = skb_color_mul_alpha(dst, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 255) - @as(c_int, @bitCast(@as(c_uint, src.a))))))));
    return skb_color_add(dst, src);
}
pub fn skb_color_premult(arg_col: skb_color_t) callconv(.c) skb_color_t {
    var col = arg_col;
    _ = &col;
    const a: i32 = @as(i32, @bitCast(@as(c_uint, col.a)));
    _ = &a;
    const r: i32 = skb_mul255(@as(i32, @bitCast(@as(c_uint, col.r))), a);
    _ = &r;
    const g: i32 = skb_mul255(@as(i32, @bitCast(@as(c_uint, col.g))), a);
    _ = &g;
    const b: i32 = skb_mul255(@as(i32, @bitCast(@as(c_uint, col.b))), a);
    _ = &b;
    var res: skb_color_t = undefined;
    _ = &res;
    res.r = @as(u8, @bitCast(@as(i8, @truncate(r))));
    res.g = @as(u8, @bitCast(@as(i8, @truncate(g))));
    res.b = @as(u8, @bitCast(@as(i8, @truncate(b))));
    res.a = @as(u8, @bitCast(@as(i8, @truncate(a))));
    return res;
}
pub const struct_skb_image_t = extern struct {
    buffer: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    width: i32 = @import("std").mem.zeroes(i32),
    height: i32 = @import("std").mem.zeroes(i32),
    stride_bytes: i32 = @import("std").mem.zeroes(i32),
    bpp: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_image_t = struct_skb_image_t;
pub const struct_skb_vec2_t = extern struct {
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_vec2_t = struct_skb_vec2_t;
pub fn skb_vec2_make(arg_x: f32, arg_y: f32) callconv(.c) skb_vec2_t {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var res: skb_vec2_t = undefined;
    _ = &res;
    res.x = x;
    res.y = y;
    return res;
}
pub fn skb_vec2_add(arg_a: skb_vec2_t, arg_b: skb_vec2_t) callconv(.c) skb_vec2_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: skb_vec2_t = undefined;
    _ = &res;
    res.x = a.x + b.x;
    res.y = a.y + b.y;
    return res;
}
pub fn skb_vec2_sub(arg_a: skb_vec2_t, arg_b: skb_vec2_t) callconv(.c) skb_vec2_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: skb_vec2_t = undefined;
    _ = &res;
    res.x = a.x - b.x;
    res.y = a.y - b.y;
    return res;
}
pub fn skb_vec2_scale(arg_a: skb_vec2_t, arg_s: f32) callconv(.c) skb_vec2_t {
    var a = arg_a;
    _ = &a;
    var s = arg_s;
    _ = &s;
    var res: skb_vec2_t = undefined;
    _ = &res;
    res.x = a.x * s;
    res.y = a.y * s;
    return res;
}
pub fn skb_vec2_mad(arg_a: skb_vec2_t, arg_b: skb_vec2_t, arg_s: f32) callconv(.c) skb_vec2_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var s = arg_s;
    _ = &s;
    var res: skb_vec2_t = undefined;
    _ = &res;
    res.x = a.x + (b.x * s);
    res.y = a.y + (b.y * s);
    return res;
}
pub fn skb_vec2_lerp(arg_a: skb_vec2_t, arg_b: skb_vec2_t, arg_t: f32) callconv(.c) skb_vec2_t {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var t = arg_t;
    _ = &t;
    var res: skb_vec2_t = undefined;
    _ = &res;
    res.x = a.x + ((b.x - a.x) * t);
    res.y = a.y + ((b.y - a.y) * t);
    return res;
}
pub fn skb_vec2_dot(arg_a: skb_vec2_t, arg_b: skb_vec2_t) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return (a.x * b.x) + (a.y * b.y);
}
pub fn skb_vec2_norm(arg_a: skb_vec2_t) callconv(.c) skb_vec2_t {
    var a = arg_a;
    _ = &a;
    const d: f32 = (a.x * a.x) + (a.y * a.y);
    _ = &d;
    if (d > 0.0) {
        const inv_d: f32 = 1.0 / sqrtf(d);
        _ = &inv_d;
        a.x *= inv_d;
        a.y *= inv_d;
    }
    return a;
}
pub fn skb_vec2_length(arg_a: skb_vec2_t) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    return sqrtf((a.x * a.x) + (a.y * a.y));
}
pub fn skb_vec2_dist_sqr(arg_a: skb_vec2_t, arg_b: skb_vec2_t) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    const dx: f32 = b.x - a.x;
    _ = &dx;
    const dy: f32 = b.y - a.y;
    _ = &dy;
    return (dx * dx) + (dy * dy);
}
pub fn skb_vec2_dist(arg_a: skb_vec2_t, arg_b: skb_vec2_t) callconv(.c) f32 {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return sqrtf(skb_vec2_dist_sqr(a, b));
}
pub fn skb_vec2_equals(arg_a: skb_vec2_t, arg_b: skb_vec2_t, arg_tol: f32) callconv(.c) bool {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var tol = arg_tol;
    _ = &tol;
    const dx: f32 = b.x - a.x;
    _ = &dx;
    const dy: f32 = b.y - a.y;
    _ = &dy;
    return ((dx * dx) + (dy * dy)) < (tol * tol);
}
pub const struct_skb_mat2_t = extern struct {
    xx: f32 = @import("std").mem.zeroes(f32),
    yx: f32 = @import("std").mem.zeroes(f32),
    xy: f32 = @import("std").mem.zeroes(f32),
    yy: f32 = @import("std").mem.zeroes(f32),
    dx: f32 = @import("std").mem.zeroes(f32),
    dy: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_mat2_t = struct_skb_mat2_t;
pub fn skb_mat2_make_identity() callconv(.c) skb_mat2_t {
    var res: skb_mat2_t = undefined;
    _ = &res;
    res.xx = 1.0;
    res.yx = 0.0;
    res.xy = 0.0;
    res.yy = 1.0;
    res.dx = 0.0;
    res.dy = 0.0;
    return res;
}
pub fn skb_mat2_make_translation(arg_tx: f32, arg_ty: f32) callconv(.c) skb_mat2_t {
    var tx = arg_tx;
    _ = &tx;
    var ty = arg_ty;
    _ = &ty;
    var res: skb_mat2_t = undefined;
    _ = &res;
    res.xx = 1.0;
    res.yx = 0.0;
    res.xy = 0.0;
    res.yy = 1.0;
    res.dx = tx;
    res.dy = ty;
    return res;
}
pub fn skb_mat2_make_scale(arg_sx: f32, arg_sy: f32) callconv(.c) skb_mat2_t {
    var sx = arg_sx;
    _ = &sx;
    var sy = arg_sy;
    _ = &sy;
    var res: skb_mat2_t = undefined;
    _ = &res;
    res.xx = sx;
    res.yx = 0.0;
    res.xy = 0.0;
    res.yy = sy;
    res.dx = 0.0;
    res.dy = 0.0;
    return res;
}
pub fn skb_mat2_make_rotation(arg_a: f32) callconv(.c) skb_mat2_t {
    var a = arg_a;
    _ = &a;
    const cs: f32 = cosf(a);
    _ = &cs;
    const sn: f32 = sinf(a);
    _ = &sn;
    var res: skb_mat2_t = undefined;
    _ = &res;
    res.xx = cs;
    res.yx = sn;
    res.xy = -sn;
    res.yy = cs;
    res.dx = 0.0;
    res.dy = 0.0;
    return res;
}
pub fn skb_mat2_multiply(arg_t: skb_mat2_t, arg_s: skb_mat2_t) callconv(.c) skb_mat2_t {
    var t = arg_t;
    _ = &t;
    var s = arg_s;
    _ = &s;
    var res: skb_mat2_t = undefined;
    _ = &res;
    res.xx = (t.xx * s.xx) + (t.yx * s.xy);
    res.yx = (t.xx * s.yx) + (t.yx * s.yy);
    res.xy = (t.xy * s.xx) + (t.yy * s.xy);
    res.yy = (t.xy * s.yx) + (t.yy * s.yy);
    res.dx = ((t.dx * s.xx) + (t.dy * s.xy)) + s.dx;
    res.dy = ((t.dx * s.yx) + (t.dy * s.yy)) + s.dy;
    return res;
}
pub fn skb_mat2_point(arg_t: skb_mat2_t, arg_pt: skb_vec2_t) callconv(.c) skb_vec2_t {
    var t = arg_t;
    _ = &t;
    var pt = arg_pt;
    _ = &pt;
    var res: skb_vec2_t = undefined;
    _ = &res;
    res.x = ((pt.x * t.xx) + (pt.y * t.xy)) + t.dx;
    res.y = ((pt.x * t.yx) + (pt.y * t.yy)) + t.dy;
    return res;
}
pub extern fn skb_mat2_inverse(t: skb_mat2_t) skb_mat2_t;
pub const struct_skb_rect2_t = extern struct {
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
    width: f32 = @import("std").mem.zeroes(f32),
    height: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_rect2_t = struct_skb_rect2_t;
pub fn skb_rect2_make_undefined() callconv(.c) skb_rect2_t {
    var res: skb_rect2_t = undefined;
    _ = &res;
    res.x = 340282346638528860000000000000000000000.0 / 2.0;
    res.y = 340282346638528860000000000000000000000.0 / 2.0;
    res.width = -340282346638528860000000000000000000000.0;
    res.height = -340282346638528860000000000000000000000.0;
    return res;
}
pub fn skb_rect2_union_point(arg_r: skb_rect2_t, arg_pt: skb_vec2_t) callconv(.c) skb_rect2_t {
    var r = arg_r;
    _ = &r;
    var pt = arg_pt;
    _ = &pt;
    const min_x: f32 = skb_minf(r.x, pt.x);
    _ = &min_x;
    const min_y: f32 = skb_minf(r.y, pt.y);
    _ = &min_y;
    const max_x: f32 = skb_maxf(r.x + r.width, pt.x);
    _ = &max_x;
    const max_y: f32 = skb_maxf(r.y + r.height, pt.y);
    _ = &max_y;
    var res: skb_rect2_t = undefined;
    _ = &res;
    res.x = min_x;
    res.y = min_y;
    res.width = max_x - min_x;
    res.height = max_y - min_y;
    return res;
}
pub fn skb_rect2_union(a: skb_rect2_t, b: skb_rect2_t) callconv(.c) skb_rect2_t {
    _ = &a;
    _ = &b;
    const min_x: f32 = skb_minf(a.x, b.x);
    _ = &min_x;
    const min_y: f32 = skb_minf(a.y, b.y);
    _ = &min_y;
    const max_x: f32 = skb_maxf(a.x + a.width, b.x + b.width);
    _ = &max_x;
    const max_y: f32 = skb_maxf(a.y + a.height, b.y + b.height);
    _ = &max_y;
    var res: skb_rect2_t = undefined;
    _ = &res;
    res.x = min_x;
    res.y = min_y;
    res.width = max_x - min_x;
    res.height = max_y - min_y;
    return res;
}
pub fn skb_rect2_intersection(a: skb_rect2_t, b: skb_rect2_t) callconv(.c) skb_rect2_t {
    _ = &a;
    _ = &b;
    const min_x: f32 = skb_maxf(a.x, b.x);
    _ = &min_x;
    const min_y: f32 = skb_maxf(a.y, b.y);
    _ = &min_y;
    const max_x: f32 = skb_minf(a.x + a.width, b.x + b.width);
    _ = &max_x;
    const max_y: f32 = skb_minf(a.y + a.height, b.y + b.height);
    _ = &max_y;
    var res: skb_rect2_t = undefined;
    _ = &res;
    res.x = min_x;
    res.y = min_y;
    res.width = max_x - min_x;
    res.height = max_y - min_y;
    return res;
}
pub fn skb_rect2_translate(r: skb_rect2_t, d: skb_vec2_t) callconv(.c) skb_rect2_t {
    _ = &r;
    _ = &d;
    var res: skb_rect2_t = undefined;
    _ = &res;
    res.x = r.x + d.x;
    res.y = r.y + d.y;
    res.width = r.width;
    res.height = r.height;
    return res;
}
pub fn skb_rect2_is_empty(r: skb_rect2_t) callconv(.c) bool {
    _ = &r;
    return (r.width <= 0.0) or (r.height <= 0.0);
}
pub fn skb_rect2_pt_inside(r: skb_rect2_t, pt: skb_vec2_t) callconv(.c) bool {
    _ = &r;
    _ = &pt;
    return (((pt.x >= r.x) and (pt.y >= r.y)) and (pt.x <= (r.x + r.width))) and (pt.y <= (r.y + r.height));
}
pub fn arb_rect2_overlap(a: skb_rect2_t, b: skb_rect2_t) callconv(.c) bool {
    _ = &a;
    _ = &b;
    const min_x: f32 = skb_maxf(a.x, b.x);
    _ = &min_x;
    const min_y: f32 = skb_maxf(a.y, b.y);
    _ = &min_y;
    const max_x: f32 = skb_minf(a.x + a.width, b.x + b.width);
    _ = &max_x;
    const max_y: f32 = skb_minf(a.y + a.height, b.y + b.height);
    _ = &max_y;
    return ((max_x - min_x) > 0.0) and ((max_y - min_y) > 0.0);
}
pub const struct_skb_rect2i_t = extern struct {
    x: i32 = @import("std").mem.zeroes(i32),
    y: i32 = @import("std").mem.zeroes(i32),
    width: i32 = @import("std").mem.zeroes(i32),
    height: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_rect2i_t = struct_skb_rect2i_t;
pub fn skb_rect2i_make_undefined() callconv(.c) skb_rect2i_t {
    var res: skb_rect2i_t = undefined;
    _ = &res;
    res.x = @divTrunc(@as(c_int, 2147483647), @as(c_int, 2));
    res.y = @divTrunc(@as(c_int, 2147483647), @as(c_int, 2));
    res.width = -@as(c_int, 2147483647) - @as(c_int, 1);
    res.height = -@as(c_int, 2147483647) - @as(c_int, 1);
    return res;
}
pub fn skb_rect2i_union_point(arg_r: skb_rect2i_t, arg_x: i32, arg_y: i32) callconv(.c) skb_rect2i_t {
    var r = arg_r;
    _ = &r;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    const min_x: i32 = skb_mini(r.x, x);
    _ = &min_x;
    const min_y: i32 = skb_mini(r.y, y);
    _ = &min_y;
    const max_x: i32 = skb_maxi(r.x + r.width, x);
    _ = &max_x;
    const max_y: i32 = skb_maxi(r.y + r.height, y);
    _ = &max_y;
    var res: skb_rect2i_t = undefined;
    _ = &res;
    res.x = min_x;
    res.y = min_y;
    res.width = max_x - min_x;
    res.height = max_y - min_y;
    return res;
}
pub fn skb_rect2i_union(a: skb_rect2i_t, b: skb_rect2i_t) callconv(.c) skb_rect2i_t {
    _ = &a;
    _ = &b;
    const min_x: i32 = skb_mini(a.x, b.x);
    _ = &min_x;
    const min_y: i32 = skb_mini(a.y, b.y);
    _ = &min_y;
    const max_x: i32 = skb_maxi(a.x + a.width, b.x + b.width);
    _ = &max_x;
    const max_y: i32 = skb_maxi(a.y + a.height, b.y + b.height);
    _ = &max_y;
    var res: skb_rect2i_t = undefined;
    _ = &res;
    res.x = min_x;
    res.y = min_y;
    res.width = max_x - min_x;
    res.height = max_y - min_y;
    return res;
}
pub fn skb_rect2i_intersection(a: skb_rect2i_t, b: skb_rect2i_t) callconv(.c) skb_rect2i_t {
    _ = &a;
    _ = &b;
    const min_x: i32 = skb_maxi(a.x, b.x);
    _ = &min_x;
    const min_y: i32 = skb_maxi(a.y, b.y);
    _ = &min_y;
    const max_x: i32 = skb_mini(a.x + a.width, b.x + b.width);
    _ = &max_x;
    const max_y: i32 = skb_mini(a.y + a.height, b.y + b.height);
    _ = &max_y;
    var res: skb_rect2i_t = undefined;
    _ = &res;
    res.x = min_x;
    res.y = min_y;
    res.width = max_x - min_x;
    res.height = max_y - min_y;
    return res;
}
pub fn skb_rect2i_is_empty(r: skb_rect2i_t) callconv(.c) bool {
    _ = &r;
    return (r.width <= @as(c_int, 0)) or (r.height <= @as(c_int, 0));
}
pub extern fn skb_calc_align_offset(@"align": skb_align_t, item_size: f32, container_size: f32) f32;
pub extern fn skb_get_directional_align(is_rtl: bool, @"align": skb_align_t) skb_align_t;
pub fn skb_hash64_empty() callconv(.c) u64 {
    return 14695981039346656037;
}
pub fn skb_hash64_append(arg_hash: u64, arg_key: ?*const anyopaque, len: usize) callconv(.c) u64 {
    var hash = arg_hash;
    _ = &hash;
    var key = arg_key;
    _ = &key;
    _ = &len;
    if (!(key != null)) return hash;
    const prime = struct {
        const static: u64 = @as(u64, @bitCast(@as(c_longlong, 1099511628211)));
    };
    _ = &prime;
    var data: [*c]const u8 = @as([*c]const u8, @ptrCast(@alignCast(key)));
    _ = &data;
    {
        var i: usize = 0;
        _ = &i;
        while (i < len) : (i +%= 1) {
            const value: u8 = data[@as(usize, @intCast(i))];
            _ = &value;
            hash = hash ^ @as(u64, @bitCast(@as(c_ulonglong, value)));
            hash *%= prime.static;
        }
    }
    return hash;
}
pub fn skb_hash64_append_float(arg_hash: u64, arg_value: f32) callconv(.c) u64 {
    var hash = arg_hash;
    _ = &hash;
    var value = arg_value;
    _ = &value;
    return skb_hash64_append(hash, @as(?*const anyopaque, @ptrCast(&value)), @sizeOf(f32));
}
pub fn skb_hash64_append_int32(arg_hash: u64, arg_value: i32) callconv(.c) u64 {
    var hash = arg_hash;
    _ = &hash;
    var value = arg_value;
    _ = &value;
    return skb_hash64_append(hash, @as(?*const anyopaque, @ptrCast(&value)), @sizeOf(i32));
}
pub fn skb_hash64_append_uint32(arg_hash: u64, arg_value: u32) callconv(.c) u64 {
    var hash = arg_hash;
    _ = &hash;
    var value = arg_value;
    _ = &value;
    return skb_hash64_append(hash, @as(?*const anyopaque, @ptrCast(&value)), @sizeOf(u32));
}
pub fn skb_hash64_append_uint64(arg_hash: u64, arg_value: u64) callconv(.c) u64 {
    var hash = arg_hash;
    _ = &hash;
    var value = arg_value;
    _ = &value;
    return skb_hash64_append(hash, @as(?*const anyopaque, @ptrCast(&value)), @sizeOf(u64));
}
pub fn skb_hash64_append_uint8(arg_hash: u64, arg_value: u8) callconv(.c) u64 {
    var hash = arg_hash;
    _ = &hash;
    var value = arg_value;
    _ = &value;
    return skb_hash64_append(hash, @as(?*const anyopaque, @ptrCast(&value)), @sizeOf(u8));
}
pub fn skb_hash64_append_str(arg_hash: u64, arg_key: [*c]const u8) callconv(.c) u64 {
    var hash = arg_hash;
    _ = &hash;
    var key = arg_key;
    _ = &key;
    if (!(key != null)) return hash;
    const prime = struct {
        const static: u64 = @as(u64, @bitCast(@as(c_longlong, 1099511628211)));
    };
    _ = &prime;
    while (key.* != 0) {
        const value: u8 = @as(u8, @bitCast(key.*));
        _ = &value;
        hash = hash ^ @as(u64, @bitCast(@as(c_ulonglong, value)));
        hash *%= prime.static;
        key += 1;
    }
    return hash;
}
pub const SKB_TEMPALLOC_DEFAULT_BLOCK_SIZE: c_int = 131072;
pub const SKB_TEMPALLOC_ALIGN: c_int = 8;
const enum_unnamed_4 = c_uint;
pub const struct_skb_temp_alloc_t = opaque {};
pub const skb_temp_alloc_t = struct_skb_temp_alloc_t;
pub const struct_skb_temp_alloc_mark_t = extern struct {
    block_num: i32 = @import("std").mem.zeroes(i32),
    offset: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_temp_alloc_mark_t = struct_skb_temp_alloc_mark_t;
pub const struct_skb_temp_alloc_stats_t = extern struct {
    allocated: i32 = @import("std").mem.zeroes(i32),
    used: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_temp_alloc_stats_t = struct_skb_temp_alloc_stats_t;
pub extern fn skb_temp_alloc_create(default_block_size: i32) ?*skb_temp_alloc_t;
pub extern fn skb_temp_alloc_destroy(alloc: ?*skb_temp_alloc_t) void;
pub extern fn skb_temp_alloc_stats(alloc: ?*skb_temp_alloc_t) skb_temp_alloc_stats_t;
pub extern fn skb_temp_alloc_reset(alloc: ?*skb_temp_alloc_t) void;
pub extern fn skb_temp_alloc_save(alloc: ?*skb_temp_alloc_t) skb_temp_alloc_mark_t;
pub extern fn skb_temp_alloc_restore(alloc: ?*skb_temp_alloc_t, mark: skb_temp_alloc_mark_t) void;
pub extern fn skb_temp_alloc_alloc(alloc: ?*skb_temp_alloc_t, size: i32) ?*anyopaque;
pub extern fn skb_temp_alloc_realloc(alloc: ?*skb_temp_alloc_t, ptr: ?*anyopaque, new_size: i32) ?*anyopaque;
pub extern fn skb_temp_alloc_free(alloc: ?*skb_temp_alloc_t, ptr: ?*anyopaque) void;
pub const struct_skb_hash_table_t = opaque {};
pub const skb_hash_table_t = struct_skb_hash_table_t;
pub extern fn skb_hash_table_create() ?*skb_hash_table_t;
pub extern fn skb_hash_table_destroy(ht: ?*skb_hash_table_t) void;
pub extern fn skb_hash_table_add(ht: ?*skb_hash_table_t, hash: u64, value: i32) bool;
pub extern fn skb_hash_table_find(ht: ?*skb_hash_table_t, hash: u64, value: [*c]i32) bool;
pub extern fn skb_hash_table_remove(ht: ?*skb_hash_table_t, hash: u64) bool;
pub const struct_skb_list_item_t = extern struct {
    prev: i32 = @import("std").mem.zeroes(i32),
    next: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_list_item_t = struct_skb_list_item_t;
pub const struct_skb_list_t = extern struct {
    head: i32 = @import("std").mem.zeroes(i32),
    tail: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_list_t = struct_skb_list_t;
pub const skb_list_get_item_func_t = fn (i32, ?*anyopaque) callconv(.c) [*c]skb_list_item_t;
pub fn skb_list_make() callconv(.c) skb_list_t {
    var res: skb_list_t = undefined;
    _ = &res;
    res.head = SKB_INVALID_INDEX;
    res.tail = SKB_INVALID_INDEX;
    return res;
}
pub fn skb_list_item_make() callconv(.c) skb_list_item_t {
    var res: skb_list_item_t = undefined;
    _ = &res;
    res.prev = SKB_INVALID_INDEX;
    res.next = SKB_INVALID_INDEX;
    return res;
}
pub fn skb_list_remove(arg_list: [*c]skb_list_t, arg_item_idx: i32, arg_get_item: ?*const skb_list_get_item_func_t, arg_context: ?*anyopaque) callconv(.c) void {
    var list = arg_list;
    _ = &list;
    var item_idx = arg_item_idx;
    _ = &item_idx;
    var get_item = arg_get_item;
    _ = &get_item;
    var context = arg_context;
    _ = &context;
    var item: [*c]skb_list_item_t = get_item.?(item_idx, context);
    _ = &item;
    if (item.*.prev != SKB_INVALID_INDEX) {
        get_item.?(item.*.prev, context).*.next = item.*.next;
    } else if (list.*.head == item_idx) {
        list.*.head = item.*.next;
    }
    if (item.*.next != SKB_INVALID_INDEX) {
        get_item.?(item.*.next, context).*.prev = item.*.prev;
    } else if (list.*.tail == item_idx) {
        list.*.tail = item.*.prev;
    }
    item.*.prev = SKB_INVALID_INDEX;
    item.*.next = SKB_INVALID_INDEX;
}
pub fn skb_list_move_to_front(arg_list: [*c]skb_list_t, arg_item_idx: i32, arg_get_item: ?*const skb_list_get_item_func_t, arg_context: ?*anyopaque) callconv(.c) void {
    var list = arg_list;
    _ = &list;
    var item_idx = arg_item_idx;
    _ = &item_idx;
    var get_item = arg_get_item;
    _ = &get_item;
    var context = arg_context;
    _ = &context;
    skb_list_remove(list, item_idx, get_item, context);
    var item: [*c]skb_list_item_t = get_item.?(item_idx, context);
    _ = &item;
    item.*.next = list.*.head;
    list.*.head = item_idx;
    if (item.*.next != SKB_INVALID_INDEX) {
        get_item.?(item.*.next, context).*.prev = item_idx;
    } else {
        list.*.tail = item_idx;
    }
}
pub const SKB_DIRECTION_AUTO: c_int = 0;
pub const SKB_DIRECTION_LTR: c_int = 1;
pub const SKB_DIRECTION_RTL: c_int = 2;
pub const skb_text_direction_t = c_uint;
pub fn skb_is_rtl(arg_direction: skb_text_direction_t) callconv(.c) bool {
    var direction = arg_direction;
    _ = &direction;
    return direction == @as(c_uint, @bitCast(SKB_DIRECTION_RTL));
}
pub const SKB_CHAR_COMBINING_ENCLOSING_CIRCLE_BACKSLASH: c_int = 8416;
pub const SKB_CHAR_COMBINING_ENCLOSING_KEYCAP: c_int = 8419;
pub const SKB_char_VARIATION_SELECTOR15: c_int = 65038;
pub const SKB_CHAR_VARIATION_SELECTOR16: c_int = 65039;
pub const SKB_CHAR_ZERO_WIDTH_JOINER: c_int = 8205;
pub const SKB_CHAR_REGIONAL_INDICATOR_BASE: c_int = 127988;
pub const SKB_CHAR_CANCEL_TAG: c_int = 917631;
pub const SKB_CHAR_HORIZONTAL_TAB: c_int = 9;
pub const SKB_CHAR_LINE_FEED: c_int = 10;
pub const SKB_CHAR_VERTICAL_TAB: c_int = 11;
pub const SKB_CHAR_FORM_FEED: c_int = 12;
pub const SKB_CHAR_CARRIAGE_RETURN: c_int = 13;
pub const SKB_CHAR_NEXT_LINE: c_int = 133;
pub const SKB_CHAR_LINE_SEPARATOR: c_int = 8232;
pub const SKB_CHAR_PARAGRAPH_SEPARATOR: c_int = 8233;
pub const SKB_CHAR_REPLACEMENT_OBJECT: c_int = 65532;
pub const skb_character_t = c_uint;
pub extern fn skb_is_emoji_modifier_base(codepoint: u32) bool;
pub extern fn skb_is_emoji_presentation(codepoint: u32) bool;
pub extern fn skb_is_emoji(codepoint: u32) bool;
pub extern fn skb_is_emoji_modifier(codepoint: u32) bool;
pub extern fn skb_is_regional_indicator_symbol(codepoint: u32) bool;
pub extern fn skb_is_variation_selector(codepoint: u32) bool;
pub extern fn skb_is_keycap_base(codepoint: u32) bool;
pub extern fn skb_is_tag_spec_char(codepoint: u32) bool;
pub extern fn skb_is_paragraph_separator(codepoint: u32) bool;
pub const struct_skb_emoji_run_iterator_t = extern struct {
    emoji_category: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    count: i32 = @import("std").mem.zeroes(i32),
    pos: i32 = @import("std").mem.zeroes(i32),
    start: i32 = @import("std").mem.zeroes(i32),
    offset: i32 = @import("std").mem.zeroes(i32),
    has_emoji: bool = @import("std").mem.zeroes(bool),
};
pub const skb_emoji_run_iterator_t = struct_skb_emoji_run_iterator_t;
pub extern fn skb_emoji_run_iterator_make(range: skb_range_t, text: [*c]const u32, emoji_category_buffer: [*c]u8) skb_emoji_run_iterator_t;
pub extern fn skb_emoji_run_iterator_next(iter: [*c]skb_emoji_run_iterator_t, range: [*c]skb_range_t, range_has_emojis: [*c]bool) bool;
pub extern fn skb_utf8_to_utf32(utf8: [*c]const u8, utf8_len: i32, utf32: [*c]u32, utf32_cap: i32) i32;
pub extern fn skb_utf8_to_utf32_count(utf8: [*c]const u8, utf8_len: i32) i32;
pub extern fn skb_utf8_codepoint_offset(utf8: [*c]const u8, utf8_len: i32, codepoint_offset: i32) i32;
pub extern fn skb_utf8_num_units(cp: u32) i32;
pub extern fn skb_utf8_encode(cp: u32, utf8: [*c]u8, utf8_cap: i32) i32;
pub extern fn skb_utf32_to_utf8(utf32: [*c]const u32, utf32_len: i32, utf8: [*c]u8, utf8_cap: i32) i32;
pub extern fn skb_utf32_to_utf8_count(utf32: [*c]const u32, utf32_len: i32) i32;
pub extern fn skb_utf32_strlen(utf32: [*c]const u32) i32;
pub extern fn skb_utf32_copy(src: [*c]const u32, src_len: i32, dst: [*c]u32, dst_cap: i32) i32;
pub extern fn skb_perf_timer_get() i64;
pub extern fn skb_perf_timer_elapsed_us(start: i64, end: i64) i64;
pub const struct_hb_font_t = opaque {};
pub const hb_font_t = struct_hb_font_t;
pub const SKB_STYLE_NORMAL: c_int = 0;
pub const SKB_STYLE_ITALIC: c_int = 1;
pub const SKB_STYLE_OBLIQUE: c_int = 2;
pub const skb_style_t = c_uint;
pub const SKB_FONT_FAMILY_DEFAULT: c_int = 0;
pub const SKB_FONT_FAMILY_EMOJI: c_int = 1;
pub const SKB_FONT_FAMILY_SANS_SERIF: c_int = 2;
pub const SKB_FONT_FAMILY_SERIF: c_int = 3;
pub const SKB_FONT_FAMILY_MONOSPACE: c_int = 4;
pub const SKB_FONT_FAMILY_MATH: c_int = 5;
pub const skb_font_family_t = c_uint;
pub const SKB_STRETCH_NORMAL: c_int = 0;
pub const SKB_STRETCH_ULTRA_CONDENSED: c_int = 1;
pub const SKB_STRETCH_EXTRA_CONDENSED: c_int = 2;
pub const SKB_STRETCH_CONDENSED: c_int = 3;
pub const SKB_STRETCH_SEMI_CONDENSED: c_int = 4;
pub const SKB_STRETCH_SEMI_EXPANDED: c_int = 5;
pub const SKB_STRETCH_EXPANDED: c_int = 6;
pub const SKB_STRETCH_EXTRA_EXPANDED: c_int = 7;
pub const SKB_STRETCH_ULTRA_EXPANDED: c_int = 8;
pub const skb_stretch_t = c_uint;
pub const SKB_WEIGHT_NORMAL: c_int = 0;
pub const SKB_WEIGHT_THIN: c_int = 1;
pub const SKB_WEIGHT_EXTRALIGHT: c_int = 2;
pub const SKB_WEIGHT_ULTRALIGHT: c_int = 3;
pub const SKB_WEIGHT_LIGHT: c_int = 4;
pub const SKB_WEIGHT_REGULAR: c_int = 5;
pub const SKB_WEIGHT_MEDIUM: c_int = 6;
pub const SKB_WEIGHT_DEMIBOLD: c_int = 7;
pub const SKB_WEIGHT_SEMIBOLD: c_int = 8;
pub const SKB_WEIGHT_BOLD: c_int = 9;
pub const SKB_WEIGHT_EXTRABOLD: c_int = 10;
pub const SKB_WEIGHT_ULTRABOLD: c_int = 11;
pub const SKB_WEIGHT_BLACK: c_int = 12;
pub const SKB_WEIGHT_HEAVY: c_int = 13;
pub const SKB_WEIGHT_EXTRABLACK: c_int = 14;
pub const SKB_WEIGHT_ULTRABLACK: c_int = 15;
pub const skb_weight_t = c_uint;
pub const SKB_BASELINE_ALPHABETIC: c_int = 0;
pub const SKB_BASELINE_IDEOGRAPHIC: c_int = 1;
pub const SKB_BASELINE_CENTRAL: c_int = 2;
pub const SKB_BASELINE_HANGING: c_int = 3;
pub const SKB_BASELINE_MATHEMATICAL: c_int = 4;
pub const SKB_BASELINE_MIDDLE: c_int = 5;
pub const SKB_BASELINE_TEXT_TOP: c_int = 6;
pub const SKB_BASELINE_TEXT_BOTTOM: c_int = 7;
pub const SKB_BASELINE_MAX: c_int = 8;
pub const skb_baseline_t = c_uint;
pub const struct_skb_font_metrics_t = extern struct {
    ascender: f32 = @import("std").mem.zeroes(f32),
    descender: f32 = @import("std").mem.zeroes(f32),
    line_gap: f32 = @import("std").mem.zeroes(f32),
    cap_height: f32 = @import("std").mem.zeroes(f32),
    x_height: f32 = @import("std").mem.zeroes(f32),
    underline_offset: f32 = @import("std").mem.zeroes(f32),
    underline_size: f32 = @import("std").mem.zeroes(f32),
    strikeout_offset: f32 = @import("std").mem.zeroes(f32),
    strikeout_size: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_font_metrics_t = struct_skb_font_metrics_t;
const struct_unnamed_6 = extern struct {
    alphabetic: f32 = @import("std").mem.zeroes(f32),
    ideographic: f32 = @import("std").mem.zeroes(f32),
    central: f32 = @import("std").mem.zeroes(f32),
    hanging: f32 = @import("std").mem.zeroes(f32),
    mathematical: f32 = @import("std").mem.zeroes(f32),
    middle: f32 = @import("std").mem.zeroes(f32),
    text_bottom: f32 = @import("std").mem.zeroes(f32),
    text_top: f32 = @import("std").mem.zeroes(f32),
};
const union_unnamed_5 = extern union {
    baselines: [8]f32,
    unnamed_0: struct_unnamed_6,
};
pub const struct_skb_baseline_set_t = extern struct {
    unnamed_0: union_unnamed_5 = @import("std").mem.zeroes(union_unnamed_5),
    script: u8 = @import("std").mem.zeroes(u8),
    direction: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_baseline_set_t = struct_skb_baseline_set_t;
pub const struct_skb_caret_metrics_t = extern struct {
    offset: f32 = @import("std").mem.zeroes(f32),
    slope: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_caret_metrics_t = struct_skb_caret_metrics_t;
pub const struct_skb_font_create_params_t = extern struct {
    embolden_x: f32 = @import("std").mem.zeroes(f32),
    embolden_y: f32 = @import("std").mem.zeroes(f32),
    slant: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_font_create_params_t = struct_skb_font_create_params_t;
pub const skb_font_handle_t = u32;
pub const struct_skb_font_collection_t = opaque {};
pub const skb_font_collection_t = struct_skb_font_collection_t;
pub const struct_skb_font_t = opaque {};
pub const skb_font_t = struct_skb_font_t;
pub const skb_font_fallback_func_t = fn (?*skb_font_collection_t, [*c]const u8, u8, u8, ?*anyopaque) callconv(.c) bool;
pub extern fn skb_font_collection_create() ?*skb_font_collection_t;
pub extern fn skb_font_collection_destroy(font_collection: ?*skb_font_collection_t) void;
pub extern fn skb_font_collection_set_on_font_fallback(font_collection: ?*skb_font_collection_t, fallback_func: ?*const skb_font_fallback_func_t, context: ?*anyopaque) void;
pub extern fn skb_font_collection_add_font_from_data(font_collection: ?*skb_font_collection_t, name: [*c]const u8, font_data: ?*const anyopaque, font_data_length: usize, context: ?*anyopaque, destroy_func: ?*const skb_destroy_func_t, font_family: u8, params: [*c]const skb_font_create_params_t) skb_font_handle_t;
pub extern fn skb_font_collection_add_font(font_collection: ?*skb_font_collection_t, file_name: [*c]const u8, font_family: u8, params: [*c]const skb_font_create_params_t) skb_font_handle_t;
pub extern fn skb_font_collection_add_hb_font(font_collection: ?*skb_font_collection_t, name: [*c]const u8, hb_font: ?*hb_font_t, font_family: u8, params: [*c]const skb_font_create_params_t) skb_font_handle_t;
pub extern fn skb_font_collection_remove_font(font_collection: ?*skb_font_collection_t, font_handle: skb_font_handle_t) bool;
pub extern fn skb_font_collection_match_fonts(font_collection: ?*skb_font_collection_t, lang: [*c]const u8, script: u8, font_family: u8, weight: skb_weight_t, style: skb_style_t, stretch: skb_stretch_t, results: [*c]skb_font_handle_t, results_cap: i32) i32;
pub extern fn skb_font_collection_font_has_codepoint(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t, codepoint: u32) bool;
pub extern fn skb_font_collection_get_default_font(font_collection: ?*skb_font_collection_t, font_family: u8) skb_font_handle_t;
pub extern fn skb_font_collection_get_font(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t) ?*skb_font_t;
pub extern fn skb_font_collection_get_id(font_collection: ?*const skb_font_collection_t) u32;
pub extern fn skb_font_get_glyph_bounds(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t, glyph_id: u32, font_size: f32) skb_rect2_t;
pub extern fn skb_font_get_metrics(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t) skb_font_metrics_t;
pub extern fn skb_font_get_caret_metrics(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t) skb_caret_metrics_t;
pub extern fn skb_font_get_hb_font(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t) ?*hb_font_t;
pub extern fn skb_font_get_baseline(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t, baseline: skb_baseline_t, direction: skb_text_direction_t, script: u8, font_size: f32) f32;
pub extern fn skb_font_get_baseline_set(font_collection: ?*const skb_font_collection_t, font_handle: skb_font_handle_t, direction: skb_text_direction_t, script: u8, font_size: f32) skb_baseline_set_t;
pub const SKB_SPREAD_PAD: c_int = 0;
pub const SKB_SPREAD_REPEAT: c_int = 1;
pub const SKB_SPREAD_REFLECT: c_int = 2;
pub const skb_gradient_spread_t = c_uint;
pub const struct_skb_canvas_t = opaque {};
pub const skb_canvas_t = struct_skb_canvas_t;
pub const struct_skb_color_stop_t = extern struct {
    offset: f32 = @import("std").mem.zeroes(f32),
    color: skb_color_t = @import("std").mem.zeroes(skb_color_t),
};
pub const skb_color_stop_t = struct_skb_color_stop_t;
pub extern fn skb_canvas_create(temp_alloc: ?*skb_temp_alloc_t, target: [*c]skb_image_t) ?*skb_canvas_t;
pub extern fn skb_canvas_destroy(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_move_to(c: ?*skb_canvas_t, pt: skb_vec2_t) void;
pub extern fn skb_canvas_line_to(c: ?*skb_canvas_t, pt: skb_vec2_t) void;
pub extern fn skb_canvas_quad_to(c: ?*skb_canvas_t, cp: skb_vec2_t, pt: skb_vec2_t) void;
pub extern fn skb_canvas_cubic_to(c: ?*skb_canvas_t, cp0: skb_vec2_t, cp1: skb_vec2_t, pt: skb_vec2_t) void;
pub extern fn skb_canvas_close(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_push_transform(c: ?*skb_canvas_t, t: skb_mat2_t) void;
pub extern fn skb_canvas_pop_transform(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_push_mask(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_pop_mask(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_push_layer(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_pop_layer(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_fill_mask(c: ?*skb_canvas_t) void;
pub extern fn skb_canvas_fill_solid_color(c: ?*skb_canvas_t, color: skb_color_t) void;
pub extern fn skb_canvas_fill_linear_gradient(c: ?*skb_canvas_t, p0: skb_vec2_t, p1: skb_vec2_t, spread: skb_gradient_spread_t, stops: [*c]const skb_color_stop_t, stops_count: i32) void;
pub extern fn skb_canvas_fill_radial_gradient(c: ?*skb_canvas_t, p0: skb_vec2_t, r0: f32, p1: skb_vec2_t, r1: f32, spread: skb_gradient_spread_t, stops: [*c]const skb_color_stop_t, stops_count: i32) void;
pub const struct_skb_icon_collection_t = opaque {};
pub const skb_icon_collection_t = struct_skb_icon_collection_t;
pub const struct_skb_icon_t = opaque {};
pub const skb_icon_t = struct_skb_icon_t;
pub const struct_skb_icon_shape_t = opaque {};
pub const skb_icon_shape_t = struct_skb_icon_shape_t;
pub const skb_icon_handle_t = u32;
pub extern fn skb_icon_collection_create() ?*skb_icon_collection_t;
pub extern fn skb_icon_collection_destroy(icon_collection: ?*skb_icon_collection_t) void;
pub extern fn skb_icon_collection_add_picosvg_icon_from_data(icon_collection: ?*skb_icon_collection_t, name: [*c]const u8, icon_data: [*c]const u8, icon_data_length: i32) skb_icon_handle_t;
pub extern fn skb_icon_collection_add_picosvg_icon(icon_collection: ?*skb_icon_collection_t, name: [*c]const u8, file_name: [*c]const u8) skb_icon_handle_t;
pub extern fn skb_icon_collection_add_icon(icon_collection: ?*skb_icon_collection_t, name: [*c]const u8, width: f32, height: f32) skb_icon_handle_t;
pub extern fn skb_icon_collection_remove_icon(icon_collection: ?*skb_icon_collection_t, icon_handle: skb_icon_handle_t) bool;
pub extern fn skb_icon_collection_find_icon(icon_collection: ?*const skb_icon_collection_t, name: [*c]const u8) skb_icon_handle_t;
pub extern fn skb_icon_collection_set_is_color(icon_collection: ?*skb_icon_collection_t, icon_handle: skb_icon_handle_t, is_color: bool) void;
pub extern fn skb_icon_collection_calc_proportional_scale(icon_collection: ?*const skb_icon_collection_t, icon_handle: skb_icon_handle_t, width: f32, height: f32) skb_vec2_t;
pub extern fn skb_icon_collection_calc_proportional_size(icon_collection: ?*const skb_icon_collection_t, icon_handle: skb_icon_handle_t, width: f32, height: f32) skb_vec2_t;
pub extern fn skb_icon_collection_get_icon_size(icon_collection: ?*const skb_icon_collection_t, icon_handle: skb_icon_handle_t) skb_vec2_t;
pub extern fn skb_icon_collection_get_icon(icon_collection: ?*const skb_icon_collection_t, icon_handle: skb_icon_handle_t) ?*const skb_icon_t;
pub extern fn skb_icon_collection_get_id(icon_collection: ?*const skb_icon_collection_t) u32;
pub const SKB_ICON_BUILDER_MAX_NESTED_SHAPES: c_int = 8;
const enum_unnamed_7 = c_uint;
pub const struct_skb_icon_builder_t = extern struct {
    icon_collection: ?*skb_icon_collection_t = @import("std").mem.zeroes(?*skb_icon_collection_t),
    icon_handle: skb_icon_handle_t = @import("std").mem.zeroes(skb_icon_handle_t),
    shape_stack: [8]?*skb_icon_shape_t = @import("std").mem.zeroes([8]?*skb_icon_shape_t),
    shape_stack_idx: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_icon_builder_t = struct_skb_icon_builder_t;
pub extern fn skb_icon_builder_make(icon_collection: ?*skb_icon_collection_t, icon_handle: skb_icon_handle_t) skb_icon_builder_t;
pub extern fn skb_icon_builder_begin_shape(icon_builder: [*c]skb_icon_builder_t) void;
pub extern fn skb_icon_builder_end_shape(icon_builder: [*c]skb_icon_builder_t) void;
pub extern fn skb_icon_builder_move_to(icon_builder: [*c]skb_icon_builder_t, pt: skb_vec2_t) void;
pub extern fn skb_icon_builder_line_to(icon_builder: [*c]skb_icon_builder_t, pt: skb_vec2_t) void;
pub extern fn skb_icon_builder_quad_to(icon_builder: [*c]skb_icon_builder_t, cp: skb_vec2_t, pt: skb_vec2_t) void;
pub extern fn skb_icon_builder_cubic_to(icon_builder: [*c]skb_icon_builder_t, cp0: skb_vec2_t, cp1: skb_vec2_t, pt: skb_vec2_t) void;
pub extern fn skb_icon_builder_close_path(icon_builder: [*c]skb_icon_builder_t) void;
pub extern fn skb_icon_builder_fill_opacity(icon_builder: [*c]skb_icon_builder_t, opacity: f32) void;
pub extern fn skb_icon_builder_fill_color(icon_builder: [*c]skb_icon_builder_t, color: skb_color_t) void;
pub extern fn skb_icon_builder_fill_linear_gradient(icon_builder: [*c]skb_icon_builder_t, p0: skb_vec2_t, p1: skb_vec2_t, xform: skb_mat2_t, spread: skb_gradient_spread_t, stops: [*c]skb_color_stop_t, stops_count: i32) void;
pub extern fn skb_icon_builder_fill_radial_gradient(icon_builder: [*c]skb_icon_builder_t, p0: skb_vec2_t, p1: skb_vec2_t, radius: f32, xform: skb_mat2_t, spread: skb_gradient_spread_t, stops: [*c]skb_color_stop_t, stops_count: i32) void;
pub const struct_skb_attribute_text_direction_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    direction: skb_text_direction_t = @import("std").mem.zeroes(skb_text_direction_t),
};
pub const skb_attribute_text_direction_t = struct_skb_attribute_text_direction_t;
pub const struct_skb_attribute_lang_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    lang: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const skb_attribute_lang_t = struct_skb_attribute_lang_t;
pub const struct_skb_attribute_font_family_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    family: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_attribute_font_family_t = struct_skb_attribute_font_family_t;
pub const struct_skb_attribute_font_size_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    size: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_font_size_t = struct_skb_attribute_font_size_t;
pub const struct_skb_attribute_font_weight_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    weight: skb_weight_t = @import("std").mem.zeroes(skb_weight_t),
};
pub const skb_attribute_font_weight_t = struct_skb_attribute_font_weight_t;
pub const struct_skb_attribute_font_style_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    style: skb_style_t = @import("std").mem.zeroes(skb_style_t),
};
pub const skb_attribute_font_style_t = struct_skb_attribute_font_style_t;
pub const struct_skb_attribute_font_stretch_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    stretch: skb_stretch_t = @import("std").mem.zeroes(skb_stretch_t),
};
pub const skb_attribute_font_stretch_t = struct_skb_attribute_font_stretch_t;
pub const struct_skb_attribute_font_feature_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    tag: u32 = @import("std").mem.zeroes(u32),
    value: u32 = @import("std").mem.zeroes(u32),
};
pub const skb_attribute_font_feature_t = struct_skb_attribute_font_feature_t;
pub const struct_skb_attribute_letter_spacing_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    spacing: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_letter_spacing_t = struct_skb_attribute_letter_spacing_t;
pub const struct_skb_attribute_word_spacing_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    spacing: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_word_spacing_t = struct_skb_attribute_word_spacing_t;
pub const struct_skb_attribute_line_height_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    type: u8 = @import("std").mem.zeroes(u8),
    height: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_line_height_t = struct_skb_attribute_line_height_t;
pub const struct_skb_attribute_tab_stop_increment_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    increment: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_tab_stop_increment_t = struct_skb_attribute_tab_stop_increment_t;
pub const struct_skb_attribute_vertical_padding_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    before: f32 = @import("std").mem.zeroes(f32),
    after: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_vertical_padding_t = struct_skb_attribute_vertical_padding_t;
pub const struct_skb_attribute_horizontal_padding_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    start: f32 = @import("std").mem.zeroes(f32),
    end: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_horizontal_padding_t = struct_skb_attribute_horizontal_padding_t;
pub const struct_skb_attribute_indent_level_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    level: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_attribute_indent_level_t = struct_skb_attribute_indent_level_t;
pub const struct_skb_attribute_indent_increment_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    level_increment: f32 = @import("std").mem.zeroes(f32),
    first_line_increment: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_indent_increment_t = struct_skb_attribute_indent_increment_t;
pub const SKB_LIST_MARKER_NONE: c_int = 0;
pub const SKB_LIST_MARKER_CODEPOINT: c_int = 1;
pub const SKB_LIST_MARKER_COUNTER_DECIMAL: c_int = 2;
pub const SKB_LIST_MARKER_COUNTER_LOWER_LATIN: c_int = 3;
pub const SKB_LIST_MARKER_COUNTER_UPPER_LATIN: c_int = 4;
pub const skb_list_marker_style_t = c_uint;
pub const struct_skb_attribute_list_marker_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    spacing: f32 = @import("std").mem.zeroes(f32),
    codepoint: u32 = @import("std").mem.zeroes(u32),
    style: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_attribute_list_marker_t = struct_skb_attribute_list_marker_t;
pub const struct_skb_attribute_text_wrap_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    text_wrap: skb_text_wrap_t = @import("std").mem.zeroes(skb_text_wrap_t),
};
pub const skb_attribute_text_wrap_t = struct_skb_attribute_text_wrap_t;
pub const struct_skb_attribute_text_overflow_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    text_overflow: skb_text_overflow_t = @import("std").mem.zeroes(skb_text_overflow_t),
};
pub const skb_attribute_text_overflow_t = struct_skb_attribute_text_overflow_t;
pub const struct_skb_attribute_vertical_trim_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    vertical_trim: skb_vertical_trim_t = @import("std").mem.zeroes(skb_vertical_trim_t),
};
pub const skb_attribute_vertical_trim_t = struct_skb_attribute_vertical_trim_t;
pub const struct_skb_attribute_align_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    @"align": skb_align_t = @import("std").mem.zeroes(skb_align_t),
};
pub const skb_attribute_align_t = struct_skb_attribute_align_t;
pub const struct_skb_attribute_baseline_align_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    baseline: skb_baseline_t = @import("std").mem.zeroes(skb_baseline_t),
};
pub const skb_attribute_baseline_align_t = struct_skb_attribute_baseline_align_t;
pub const struct_skb_attribute_fill_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    color: skb_color_t = @import("std").mem.zeroes(skb_color_t),
};
pub const skb_attribute_fill_t = struct_skb_attribute_fill_t;
pub const struct_skb_attribute_decoration_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    position: u8 = @import("std").mem.zeroes(u8),
    style: u8 = @import("std").mem.zeroes(u8),
    thickness: f32 = @import("std").mem.zeroes(f32),
    offset: f32 = @import("std").mem.zeroes(f32),
    color: skb_color_t = @import("std").mem.zeroes(skb_color_t),
};
pub const skb_attribute_decoration_t = struct_skb_attribute_decoration_t;
pub const struct_skb_attribute_object_align_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    baseline_ratio: f32 = @import("std").mem.zeroes(f32),
    align_ref: u8 = @import("std").mem.zeroes(u8),
    align_baseline: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_attribute_object_align_t = struct_skb_attribute_object_align_t;
pub const struct_skb_attribute_object_padding_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    start: f32 = @import("std").mem.zeroes(f32),
    end: f32 = @import("std").mem.zeroes(f32),
    top: f32 = @import("std").mem.zeroes(f32),
    bottom: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_attribute_object_padding_t = struct_skb_attribute_object_padding_t;
pub const skb_attribute_set_handle_t = u64;
pub const struct_skb_attribute_reference_t = extern struct {
    kind: u32 = @import("std").mem.zeroes(u32),
    handle: skb_attribute_set_handle_t = @import("std").mem.zeroes(skb_attribute_set_handle_t),
};
pub const skb_attribute_reference_t = struct_skb_attribute_reference_t;
pub const SKB_ATTRIBUTE_TEXT_DIRECTION: c_int = 1952737650;
pub const SKB_ATTRIBUTE_LANG: c_int = 1818324583;
pub const SKB_ATTRIBUTE_FONT_FAMILY: c_int = 1718578804;
pub const SKB_ATTRIBUTE_FONT_STRETCH: c_int = 1718842482;
pub const SKB_ATTRIBUTE_FONT_SIZE: c_int = 1718839674;
pub const SKB_ATTRIBUTE_FONT_WEIGHT: c_int = 1719100777;
pub const SKB_ATTRIBUTE_FONT_STYLE: c_int = 1718842489;
pub const SKB_ATTRIBUTE_FONT_FEATURE: c_int = 1717920116;
pub const SKB_ATTRIBUTE_LETTER_SPACING: c_int = 1818588016;
pub const SKB_ATTRIBUTE_WORD_SPACING: c_int = 2003792752;
pub const SKB_ATTRIBUTE_LINE_HEIGHT: c_int = 1819175013;
pub const SKB_ATTRIBUTE_TAB_STOP_INCREMENT: c_int = 1952539251;
pub const SKB_ATTRIBUTE_VERTICAL_PADDING: c_int = 1987076452;
pub const SKB_ATTRIBUTE_HORIZONTAL_PADDING: c_int = 1752195428;
pub const SKB_ATTRIBUTE_INDENT_LEVEL: c_int = 1768715884;
pub const SKB_ATTRIBUTE_INDENT_INCREMENT: c_int = 1768517219;
pub const SKB_ATTRIBUTE_LIST_MARKER: c_int = 1818848619;
pub const SKB_ATTRIBUTE_TEXT_WRAP: c_int = 1953985136;
pub const SKB_ATTRIBUTE_TEXT_OVERFLOW: c_int = 1953457772;
pub const SKB_ATTRIBUTE_VERTICAL_TRIM: c_int = 1987342957;
pub const SKB_ATTRIBUTE_HORIZONTAL_ALIGN: c_int = 1751215214;
pub const SKB_ATTRIBUTE_VERTICAL_ALIGN: c_int = 1986096238;
pub const SKB_ATTRIBUTE_BASELINE_ALIGN: c_int = 1650551918;
pub const SKB_ATTRIBUTE_FILL: c_int = 1718185068;
pub const SKB_ATTRIBUTE_DECORATION: c_int = 1684366191;
pub const SKB_ATTRIBUTE_OBJECT_ALIGN: c_int = 1868718444;
pub const SKB_ATTRIBUTE_OBJECT_PADDING: c_int = 1868722273;
pub const SKB_ATTRIBUTE_REFERENCE: c_int = 1634887014;
pub const skb_attribute_type_t = c_uint;
pub const union_skb_attribute_t = extern union {
    kind: u32,
    text_direction: skb_attribute_text_direction_t,
    lang: skb_attribute_lang_t,
    font_family: skb_attribute_font_family_t,
    font_size: skb_attribute_font_size_t,
    font_weight: skb_attribute_font_weight_t,
    font_style: skb_attribute_font_style_t,
    font_stretch: skb_attribute_font_stretch_t,
    font_feature: skb_attribute_font_feature_t,
    letter_spacing: skb_attribute_letter_spacing_t,
    word_spacing: skb_attribute_word_spacing_t,
    line_height: skb_attribute_line_height_t,
    tab_stop_increment: skb_attribute_tab_stop_increment_t,
    vertical_padding: skb_attribute_vertical_padding_t,
    horizontal_padding: skb_attribute_horizontal_padding_t,
    indent_level: skb_attribute_indent_level_t,
    indent_increment: skb_attribute_indent_increment_t,
    list_marker: skb_attribute_list_marker_t,
    text_wrap: skb_attribute_text_wrap_t,
    text_overflow: skb_attribute_text_overflow_t,
    vertical_trim: skb_attribute_vertical_trim_t,
    horizontal_align: skb_attribute_align_t,
    vertical_align: skb_attribute_align_t,
    baseline_align: skb_attribute_baseline_align_t,
    fill: skb_attribute_fill_t,
    decoration: skb_attribute_decoration_t,
    object_align: skb_attribute_object_align_t,
    object_padding: skb_attribute_object_padding_t,
    reference: skb_attribute_reference_t,
};
pub const skb_attribute_t = union_skb_attribute_t;
pub const struct_skb_attribute_collection_t = opaque {};
pub const skb_attribute_collection_t = struct_skb_attribute_collection_t;
pub const struct_skb_attribute_set_t = extern struct {
    attributes: [*c]const skb_attribute_t = @import("std").mem.zeroes([*c]const skb_attribute_t),
    attributes_count: i32 = @import("std").mem.zeroes(i32),
    set_handle: skb_attribute_set_handle_t = @import("std").mem.zeroes(skb_attribute_set_handle_t),
    parent_set: [*c]const struct_skb_attribute_set_t = @import("std").mem.zeroes([*c]const struct_skb_attribute_set_t),
};
pub const skb_attribute_set_t = struct_skb_attribute_set_t;
pub extern fn skb_attribute_set_make_reference(handle: skb_attribute_set_handle_t) skb_attribute_set_t;
pub extern fn skb_attribute_set_make_reference_by_name(attribute_collection: ?*const skb_attribute_collection_t, name: [*c]const u8) skb_attribute_set_t;
pub extern fn skb_attribute_make_text_direction(direction: skb_text_direction_t) skb_attribute_t;
pub extern fn skb_attribute_make_lang(lang: [*c]const u8) skb_attribute_t;
pub extern fn skb_attribute_make_font_family(family: u8) skb_attribute_t;
pub extern fn skb_attribute_make_font_size(size: f32) skb_attribute_t;
pub extern fn skb_attribute_make_font_weight(weight: skb_weight_t) skb_attribute_t;
pub extern fn skb_attribute_make_font_style(style: skb_style_t) skb_attribute_t;
pub extern fn skb_attribute_make_font_stretch(stretch: skb_stretch_t) skb_attribute_t;
pub extern fn skb_attribute_make_font_feature(tag: u32, value: u32) skb_attribute_t;
pub extern fn skb_attribute_make_letter_spacing(letter_spacing: f32) skb_attribute_t;
pub extern fn skb_attribute_make_word_spacing(word_spacing: f32) skb_attribute_t;
pub extern fn skb_attribute_make_line_height(@"type": skb_line_height_t, height: f32) skb_attribute_t;
pub extern fn skb_attribute_make_tab_stop_increment(increment: f32) skb_attribute_t;
pub extern fn skb_attribute_make_vertical_padding(top: f32, bottom: f32) skb_attribute_t;
pub extern fn skb_attribute_make_horizontal_padding(start: f32, end: f32) skb_attribute_t;
pub extern fn skb_attribute_make_indent_level(level: i32) skb_attribute_t;
pub extern fn skb_attribute_make_indent_increment(level_increment: f32, first_line_increment: f32) skb_attribute_t;
pub extern fn skb_attribute_make_list_marker(style: skb_list_marker_style_t, spacing: f32, codepoint: u32) skb_attribute_t;
pub extern fn skb_attribute_make_text_wrap(text_wrap: skb_text_wrap_t) skb_attribute_t;
pub extern fn skb_attribute_make_text_overflow(text_overflow: skb_text_overflow_t) skb_attribute_t;
pub extern fn skb_attribute_make_vertical_trim(vertical_trim: skb_vertical_trim_t) skb_attribute_t;
pub extern fn skb_attribute_make_horizontal_align(horizontal_align: skb_align_t) skb_attribute_t;
pub extern fn skb_attribute_make_vertical_align(vertical_align: skb_align_t) skb_attribute_t;
pub extern fn skb_attribute_make_baseline_align(baseline_align: skb_baseline_t) skb_attribute_t;
pub extern fn skb_attribute_make_fill(color: skb_color_t) skb_attribute_t;
pub extern fn skb_attribute_make_decoration(position: skb_decoration_position_t, style: skb_decoration_style_t, thickness: f32, offset: f32, color: skb_color_t) skb_attribute_t;
pub extern fn skb_attribute_make_object_align(baseline_ratio: f32, align_ref: skb_object_align_reference_t, align_baseline: skb_baseline_t) skb_attribute_t;
pub extern fn skb_attribute_make_object_padding(start: f32, end: f32, top: f32, bottom: f32) skb_attribute_t;
pub extern fn skb_attribute_make_object_padding_hv(horizontal: f32, vertical: f32) skb_attribute_t;
pub extern fn skb_attribute_make_reference(set_handle: skb_attribute_set_handle_t) skb_attribute_t;
pub extern fn skb_attribute_make_reference_by_name(attribute_collection: ?*const skb_attribute_collection_t, name: [*c]const u8) skb_attribute_t;
pub extern fn skb_attributes_get_text_direction(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_text_direction_t;
pub extern fn skb_attributes_get_lang(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) [*c]const u8;
pub extern fn skb_attributes_get_font_family(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) u8;
pub extern fn skb_attributes_get_font_size(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) f32;
pub extern fn skb_attributes_get_font_weight(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_weight_t;
pub extern fn skb_attributes_get_font_style(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_style_t;
pub extern fn skb_attributes_get_font_stretch(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_stretch_t;
pub extern fn skb_attributes_get_letter_spacing(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) f32;
pub extern fn skb_attributes_get_word_spacing(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) f32;
pub extern fn skb_attributes_get_line_height(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_line_height_t;
pub extern fn skb_attributes_get_tab_stop_increment(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) f32;
pub extern fn skb_attributes_get_vertical_padding(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_vertical_padding_t;
pub extern fn skb_attributes_get_horizontal_padding(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_horizontal_padding_t;
pub extern fn skb_attributes_get_indent_level(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) i32;
pub extern fn skb_attributes_get_indent_increment(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_indent_increment_t;
pub extern fn skb_attributes_get_list_marker(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_list_marker_t;
pub extern fn skb_attributes_get_fill(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_fill_t;
pub extern fn skb_attributes_get_object_align(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_object_align_t;
pub extern fn skb_attributes_get_object_padding(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_attribute_object_padding_t;
pub extern fn skb_attributes_get_text_wrap(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_text_wrap_t;
pub extern fn skb_attributes_get_text_overflow(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_text_overflow_t;
pub extern fn skb_attributes_get_vertical_trim(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_vertical_trim_t;
pub extern fn skb_attributes_get_horizontal_align(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_align_t;
pub extern fn skb_attributes_get_vertical_align(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_align_t;
pub extern fn skb_attributes_get_baseline_align(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t) skb_baseline_t;
pub extern fn skb_attributes_get_by_kind(attributes: skb_attribute_set_t, collection: ?*const skb_attribute_collection_t, kind: u32, results: [*c][*c]const skb_attribute_t, results_cap: i32) i32;
pub extern fn skb_attributes_get_copy_flat_count(attributes: skb_attribute_set_t) i32;
pub extern fn skb_attributes_copy_flat(attributes: skb_attribute_set_t, dest: [*c]skb_attribute_t, dest_cap: i32) i32;
pub extern fn skb_attributes_hash_append(hash: u64, attributes: skb_attribute_set_t) u64;
pub fn skb_attribute_set_handle_get_group(arg_handle: skb_attribute_set_handle_t) callconv(.c) i32 {
    var handle = arg_handle;
    _ = &handle;
    return @as(i32, @bitCast(@as(c_uint, @truncate(handle & @as(skb_attribute_set_handle_t, @bitCast(@as(c_ulonglong, @as(c_uint, 4294967295))))))));
}
pub extern fn skb_attribute_collection_create() ?*skb_attribute_collection_t;
pub extern fn skb_attribute_collection_destroy(attribute_collection: ?*skb_attribute_collection_t) void;
pub extern fn skb_attribute_collection_get_id(attribute_collection: ?*const skb_attribute_collection_t) u32;
pub extern fn skb_attribute_collection_add_set(attribute_collection: ?*skb_attribute_collection_t, name: [*c]const u8, attributes: skb_attribute_set_t) skb_attribute_set_handle_t;
pub extern fn skb_attribute_collection_add_set_with_group(attribute_collection: ?*skb_attribute_collection_t, name: [*c]const u8, group_name: [*c]const u8, attributes: skb_attribute_set_t) skb_attribute_set_handle_t;
pub extern fn skb_attribute_collection_find_set_by_name(attribute_collection: ?*const skb_attribute_collection_t, name: [*c]const u8) skb_attribute_set_handle_t;
pub extern fn skb_attribute_collection_get_set(attribute_collection: ?*const skb_attribute_collection_t, handle: skb_attribute_set_handle_t) skb_attribute_set_t;
pub extern fn skb_attribute_collection_get_set_by_name(attribute_collection: ?*const skb_attribute_collection_t, name: [*c]const u8) skb_attribute_set_t;
pub const SKB_MAX_ACTIVE_ATTRIBUTES: c_int = 64;
const enum_unnamed_8 = c_uint;
pub const struct_skb_attribute_span_t = extern struct {
    text_range: skb_range_t = @import("std").mem.zeroes(skb_range_t),
    attribute: skb_attribute_t = @import("std").mem.zeroes(skb_attribute_t),
};
pub const skb_attribute_span_t = struct_skb_attribute_span_t;
pub const struct_skb_text_t = opaque {};
pub const skb_text_t = struct_skb_text_t;
pub extern fn skb_text_create() ?*skb_text_t;
pub extern fn skb_text_create_temp(temp_alloc: ?*skb_temp_alloc_t) ?*skb_text_t;
pub extern fn skb_text_destroy(text: ?*skb_text_t) void;
pub extern fn skb_text_reset(text: ?*skb_text_t) void;
pub extern fn skb_text_reserve(text: ?*skb_text_t, text_count: i32, spans_count: i32) void;
pub extern fn skb_text_get_utf32_count(text: ?*const skb_text_t) i32;
pub extern fn skb_text_get_utf32(text: ?*const skb_text_t) [*c]const u32;
pub extern fn skb_text_sanitize_range(text: ?*const skb_text_t, range: skb_range_t) skb_range_t;
pub extern fn skb_text_get_attribute_spans_count(text: ?*const skb_text_t) i32;
pub extern fn skb_text_get_attribute_spans(text: ?*const skb_text_t) [*c]const skb_attribute_span_t;
pub extern fn skb_text_append(text: ?*skb_text_t, text_from: ?*const skb_text_t) void;
pub extern fn skb_text_append_range(text: ?*skb_text_t, from_text: ?*const skb_text_t, from_range: skb_range_t) void;
pub extern fn skb_text_append_utf8(text: ?*skb_text_t, utf8: [*c]const u8, utf8_count: i32, attributes: skb_attribute_set_t) void;
pub extern fn skb_text_append_utf32(text: ?*skb_text_t, utf32: [*c]const u32, utf32_count: i32, attributes: skb_attribute_set_t) void;
pub extern fn skb_text_replace(text: ?*skb_text_t, range: skb_range_t, other: ?*const skb_text_t) void;
pub extern fn skb_text_replace_utf8(text: ?*skb_text_t, range: skb_range_t, utf8: [*c]const u8, utf8_count: i32, attributes: skb_attribute_set_t) void;
pub extern fn skb_text_replace_utf32(text: ?*skb_text_t, range: skb_range_t, utf32: [*c]const u32, utf32_count: i32, attributes: skb_attribute_set_t) void;
pub extern fn skb_text_remove(text: ?*skb_text_t, range: skb_range_t) void;
pub const skb_text_remove_func_t = fn (u32, i32, ?*anyopaque) callconv(.c) bool;
pub extern fn skb_text_remove_if(text: ?*skb_text_t, filter_func: ?*const skb_text_remove_func_t, context: ?*anyopaque) void;
pub extern fn skb_text_clear_attribute(text: ?*skb_text_t, range: skb_range_t, attribute: skb_attribute_t) void;
pub extern fn skb_text_clear_all_attributes(text: ?*skb_text_t, range: skb_range_t) void;
pub extern fn skb_text_add_attribute(text: ?*skb_text_t, range: skb_range_t, attribute: skb_attribute_t) void;
pub const skb_attribute_run_iterator_func_t = fn (?*const skb_text_t, skb_range_t, [*c][*c]skb_attribute_span_t, i32, ?*anyopaque) callconv(.c) void;
pub extern fn skb_text_iterate_attribute_runs(text: ?*const skb_text_t, callback: ?*const skb_attribute_run_iterator_func_t, context: ?*anyopaque) void;
pub const struct_hb_language_impl_t = opaque {};
pub const hb_language_t = ?*const struct_hb_language_impl_t;
pub const SKB_LAYOUT_PARAMS_IGNORE_MUST_LINE_BREAKS: c_int = 1;
pub const SKB_LAYOUT_PARAMS_IGNORE_VERTICAL_ALIGN: c_int = 2;
pub const enum_skb_layout_params_flags_t = c_uint;
pub const struct_skb_layout_params_t = extern struct {
    font_collection: ?*skb_font_collection_t = @import("std").mem.zeroes(?*skb_font_collection_t),
    icon_collection: ?*skb_icon_collection_t = @import("std").mem.zeroes(?*skb_icon_collection_t),
    attribute_collection: ?*skb_attribute_collection_t = @import("std").mem.zeroes(?*skb_attribute_collection_t),
    layout_width: f32 = @import("std").mem.zeroes(f32),
    layout_height: f32 = @import("std").mem.zeroes(f32),
    flags: u8 = @import("std").mem.zeroes(u8),
    layout_attributes: skb_attribute_set_t = @import("std").mem.zeroes(skb_attribute_set_t),
    list_marker_counter: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_layout_params_t = struct_skb_layout_params_t;
pub const struct_skb_content_text_utf8_t = extern struct {
    text: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    text_count: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_content_text_utf8_t = struct_skb_content_text_utf8_t;
pub const struct_skb_content_text_utf32_t = extern struct {
    text: [*c]const u32 = @import("std").mem.zeroes([*c]const u32),
    text_count: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_content_text_utf32_t = struct_skb_content_text_utf32_t;
pub const struct_skb_content_object_t = extern struct {
    width: f32 = @import("std").mem.zeroes(f32),
    height: f32 = @import("std").mem.zeroes(f32),
    data: isize = @import("std").mem.zeroes(isize),
};
pub const skb_content_object_t = struct_skb_content_object_t;
pub const struct_skb_content_icon_t = extern struct {
    width: f32 = @import("std").mem.zeroes(f32),
    height: f32 = @import("std").mem.zeroes(f32),
    icon_handle: skb_icon_handle_t = @import("std").mem.zeroes(skb_icon_handle_t),
};
pub const skb_content_icon_t = struct_skb_content_icon_t;
pub const SKB_CONTENT_RUN_UTF8: c_int = 0;
pub const SKB_CONTENT_RUN_UTF32: c_int = 1;
pub const SKB_CONTENT_RUN_OBJECT: c_int = 2;
pub const SKB_CONTENT_RUN_ICON: c_int = 3;
pub const skb_content_run_type_t = c_uint;
const union_unnamed_9 = extern union {
    utf8: skb_content_text_utf8_t,
    utf32: skb_content_text_utf32_t,
    object: skb_content_object_t,
    icon: skb_content_icon_t,
};
pub const struct_skb_content_run_t = extern struct {
    unnamed_0: union_unnamed_9 = @import("std").mem.zeroes(union_unnamed_9),
    run_id: isize = @import("std").mem.zeroes(isize),
    attributes: skb_attribute_set_t = @import("std").mem.zeroes(skb_attribute_set_t),
    type: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_content_run_t = struct_skb_content_run_t;
pub extern fn skb_content_run_make_utf8(text: [*c]const u8, text_count: i32, attributes: skb_attribute_set_t, run_id: isize) skb_content_run_t;
pub extern fn skb_content_run_make_utf32(text: [*c]const u32, text_count: i32, attributes: skb_attribute_set_t, run_id: isize) skb_content_run_t;
pub extern fn skb_content_run_make_object(data: isize, width: f32, height: f32, attributes: skb_attribute_set_t, run_id: isize) skb_content_run_t;
pub extern fn skb_content_run_make_icon(icon_handle: skb_icon_handle_t, width: f32, height: f32, attributes: skb_attribute_set_t, run_id: isize) skb_content_run_t;
pub const SKB_LAYOUT_LINE_IS_TRUNCATED: c_int = 1;
pub const skb_layout_line_flags_t = c_uint;
pub const struct_skb_layout_line_t = extern struct {
    text_range: skb_range_t = @import("std").mem.zeroes(skb_range_t),
    layout_run_range: skb_range_t = @import("std").mem.zeroes(skb_range_t),
    decorations_range: skb_range_t = @import("std").mem.zeroes(skb_range_t),
    last_grapheme_offset: i32 = @import("std").mem.zeroes(i32),
    ascender: f32 = @import("std").mem.zeroes(f32),
    descender: f32 = @import("std").mem.zeroes(f32),
    baseline: f32 = @import("std").mem.zeroes(f32),
    bounds: skb_rect2_t = @import("std").mem.zeroes(skb_rect2_t),
    culling_bounds: skb_rect2_t = @import("std").mem.zeroes(skb_rect2_t),
    common_glyph_bounds: skb_rect2_t = @import("std").mem.zeroes(skb_rect2_t),
    flags: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_layout_line_t = struct_skb_layout_line_t;
const union_unnamed_10 = extern union {
    font_handle: skb_font_handle_t,
    object_data: isize,
    icon_handle: skb_icon_handle_t,
};
pub const struct_skb_layout_run_t = extern struct {
    type: u8 = @import("std").mem.zeroes(u8),
    direction: u8 = @import("std").mem.zeroes(u8),
    script: u8 = @import("std").mem.zeroes(u8),
    bidi_level: u8 = @import("std").mem.zeroes(u8),
    content_run_idx: i32 = @import("std").mem.zeroes(i32),
    glyph_range: skb_range_t = @import("std").mem.zeroes(skb_range_t),
    cluster_range: skb_range_t = @import("std").mem.zeroes(skb_range_t),
    bounds: skb_rect2_t = @import("std").mem.zeroes(skb_rect2_t),
    ref_baseline: f32 = @import("std").mem.zeroes(f32),
    font_size: f32 = @import("std").mem.zeroes(f32),
    attributes: skb_attribute_set_t = @import("std").mem.zeroes(skb_attribute_set_t),
    content_run_id: isize = @import("std").mem.zeroes(isize),
    unnamed_0: union_unnamed_10 = @import("std").mem.zeroes(union_unnamed_10),
};
pub const skb_layout_run_t = struct_skb_layout_run_t;
pub const struct_skb_cluster_t = extern struct {
    text_offset: i32 = @import("std").mem.zeroes(i32),
    glyphs_offset: i32 = @import("std").mem.zeroes(i32),
    text_count: u8 = @import("std").mem.zeroes(u8),
    glyphs_count: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_cluster_t = struct_skb_cluster_t;
pub const struct_skb_glyph_t = extern struct {
    offset_x: f32 = @import("std").mem.zeroes(f32),
    offset_y: f32 = @import("std").mem.zeroes(f32),
    advance_x: f32 = @import("std").mem.zeroes(f32),
    cluster_idx: i32 = @import("std").mem.zeroes(i32),
    gid: u16 = @import("std").mem.zeroes(u16),
};
pub const skb_glyph_t = struct_skb_glyph_t;
pub const struct_skb_decoration_t = extern struct {
    layout_run_idx: i32 = @import("std").mem.zeroes(i32),
    glyph_range: skb_range_t = @import("std").mem.zeroes(skb_range_t),
    offset_x: f32 = @import("std").mem.zeroes(f32),
    offset_y: f32 = @import("std").mem.zeroes(f32),
    length: f32 = @import("std").mem.zeroes(f32),
    pattern_offset: f32 = @import("std").mem.zeroes(f32),
    thickness: f32 = @import("std").mem.zeroes(f32),
    color: skb_color_t = @import("std").mem.zeroes(skb_color_t),
    position: u8 = @import("std").mem.zeroes(u8),
    style: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_decoration_t = struct_skb_decoration_t;
pub const SKB_TEXT_PROP_GRAPHEME_BREAK: c_int = 1;
pub const SKB_TEXT_PROP_WORD_BREAK: c_int = 2;
pub const SKB_TEXT_PROP_MUST_LINE_BREAK: c_int = 4;
pub const SKB_TEXT_PROP_ALLOW_LINE_BREAK: c_int = 8;
pub const SKB_TEXT_PROP_EMOJI: c_int = 16;
pub const SKB_TEXT_PROP_CONTROL: c_int = 32;
pub const SKB_TEXT_PROP_WHITESPACE: c_int = 64;
pub const SKB_TEXT_PROP_PUNCTUATION: c_int = 128;
pub const enum_skb_text_prop_flags_t = c_uint;
pub const struct_skb_text_property_t = extern struct {
    flags: u8 = @import("std").mem.zeroes(u8),
    script: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_text_property_t = struct_skb_text_property_t;
pub const struct_skb_layout_t = opaque {};
pub const skb_layout_t = struct_skb_layout_t;
pub extern fn skb_layout_params_hash_append(hash: u64, params: [*c]const skb_layout_params_t) u64;
pub extern fn skb_layout_create(params: [*c]const skb_layout_params_t) ?*skb_layout_t;
pub extern fn skb_layout_create_utf8(temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: [*c]const u8, text_count: i32, attributes: skb_attribute_set_t) ?*skb_layout_t;
pub extern fn skb_layout_create_utf32(temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: [*c]const u32, text_count: i32, attributes: skb_attribute_set_t) ?*skb_layout_t;
pub extern fn skb_layout_create_from_runs(temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, runs: [*c]const skb_content_run_t, runs_count: i32) ?*skb_layout_t;
pub extern fn skb_layout_create_from_text(temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: ?*const skb_text_t, attributes: skb_attribute_set_t) ?*skb_layout_t;
pub extern fn skb_layout_set_utf8(layout: ?*skb_layout_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: [*c]const u8, text_count: i32, attributes: skb_attribute_set_t) void;
pub extern fn skb_layout_set_utf32(layout: ?*skb_layout_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: [*c]const u32, text_count: i32, attributes: skb_attribute_set_t) void;
pub extern fn skb_layout_set_from_runs(layout: ?*skb_layout_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, runs: [*c]const skb_content_run_t, runs_count: i32) void;
pub extern fn skb_layout_set_from_text(layout: ?*skb_layout_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: ?*const skb_text_t, attributes: skb_attribute_set_t) void;
pub extern fn skb_layout_reset(layout: ?*skb_layout_t) void;
pub extern fn skb_layout_destroy(layout: ?*skb_layout_t) void;
pub extern fn skb_layout_get_params(layout: ?*const skb_layout_t) [*c]const skb_layout_params_t;
pub extern fn skb_layout_get_text_count(layout: ?*const skb_layout_t) i32;
pub extern fn skb_layout_get_text(layout: ?*const skb_layout_t) [*c]const u32;
pub extern fn skb_layout_get_text_properties(layout: ?*const skb_layout_t) [*c]const skb_text_property_t;
pub extern fn skb_layout_get_layout_runs_count(layout: ?*const skb_layout_t) i32;
pub extern fn skb_layout_get_layout_runs(layout: ?*const skb_layout_t) [*c]const skb_layout_run_t;
pub extern fn skb_layout_get_glyphs_count(layout: ?*const skb_layout_t) i32;
pub extern fn skb_layout_get_glyphs(layout: ?*const skb_layout_t) [*c]const skb_glyph_t;
pub extern fn skb_layout_get_clusters_count(layout: ?*const skb_layout_t) i32;
pub extern fn skb_layout_get_clusters(layout: ?*const skb_layout_t) [*c]const skb_cluster_t;
pub extern fn skb_layout_get_decorations_count(layout: ?*const skb_layout_t) i32;
pub extern fn skb_layout_get_decorations(layout: ?*const skb_layout_t) [*c]const skb_decoration_t;
pub extern fn skb_layout_get_lines_count(layout: ?*const skb_layout_t) i32;
pub extern fn skb_layout_get_lines(layout: ?*const skb_layout_t) [*c]const skb_layout_line_t;
pub extern fn skb_layout_get_bounds(layout: ?*const skb_layout_t) skb_rect2_t;
pub extern fn skb_layout_get_advance_y(layout: ?*const skb_layout_t) f32;
pub extern fn skb_layout_get_resolved_direction(layout: ?*const skb_layout_t) skb_text_direction_t;
pub extern fn skb_layout_next_grapheme_offset(layout: ?*const skb_layout_t, text_offset: i32) i32;
pub extern fn skb_layout_prev_grapheme_offset(layout: ?*const skb_layout_t, text_offset: i32) i32;
pub extern fn skb_layout_align_grapheme_offset(layout: ?*const skb_layout_t, text_offset: i32) i32;
pub const struct_skb_visual_caret_t = extern struct {
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
    ascender: f32 = @import("std").mem.zeroes(f32),
    descender: f32 = @import("std").mem.zeroes(f32),
    slope: f32 = @import("std").mem.zeroes(f32),
    direction: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_visual_caret_t = struct_skb_visual_caret_t;
pub extern fn skb_layout_get_line_index(layout: ?*const skb_layout_t, pos: skb_text_position_t) i32;
pub extern fn skb_layout_get_text_offset(layout: ?*const skb_layout_t, pos: skb_text_position_t) i32;
pub extern fn skb_layout_get_text_direction_at(layout: ?*const skb_layout_t, pos: skb_text_position_t) skb_text_direction_t;
pub const SKB_MOVEMENT_CARET: c_int = 0;
pub const SKB_MOVEMENT_SELECTION: c_int = 1;
pub const skb_movement_type_t = c_uint;
pub extern fn skb_layout_hit_test_at_line(layout: ?*const skb_layout_t, @"type": skb_movement_type_t, line_idx: i32, hit_x: f32) skb_text_position_t;
pub extern fn skb_layout_hit_test(layout: ?*const skb_layout_t, @"type": skb_movement_type_t, hit_x: f32, hit_y: f32) skb_text_position_t;
pub const struct_skb_layout_content_hit_t = extern struct {
    run_id: isize = @import("std").mem.zeroes(isize),
    line_idx: i32 = @import("std").mem.zeroes(i32),
    layout_run_idx: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_layout_content_hit_t = struct_skb_layout_content_hit_t;
pub extern fn skb_layout_hit_test_content_at_line(layout: ?*const skb_layout_t, line_idx: i32, hit_x: f32) skb_layout_content_hit_t;
pub extern fn skb_layout_hit_test_content(layout: ?*const skb_layout_t, hit_x: f32, hit_y: f32) skb_layout_content_hit_t;
pub const skb_content_rect_func_t = fn (skb_rect2_t, i32, i32, ?*anyopaque) callconv(.c) void;
pub extern fn skb_layout_get_content_bounds_at_line(layout: ?*const skb_layout_t, line_idx: i32, run_id: isize, callback: ?*const skb_content_rect_func_t, context: ?*anyopaque) void;
pub extern fn skb_layout_get_content_bounds(layout: ?*const skb_layout_t, run_id: isize, callback: ?*const skb_content_rect_func_t, context: ?*anyopaque) void;
pub extern fn skb_layout_get_visual_caret_at_line(layout: ?*const skb_layout_t, line_idx: i32, pos: skb_text_position_t) skb_visual_caret_t;
pub extern fn skb_layout_get_visual_caret_at(layout: ?*const skb_layout_t, pos: skb_text_position_t) skb_visual_caret_t;
pub extern fn skb_layout_get_line_start_at(layout: ?*const skb_layout_t, pos: skb_text_position_t) skb_text_position_t;
pub extern fn skb_layout_get_line_end_at(layout: ?*const skb_layout_t, pos: skb_text_position_t) skb_text_position_t;
pub extern fn skb_layout_get_word_start_at(layout: ?*const skb_layout_t, pos: skb_text_position_t) skb_text_position_t;
pub extern fn skb_layout_get_word_end_at(layout: ?*const skb_layout_t, pos: skb_text_position_t) skb_text_position_t;
pub extern fn skb_layout_get_selection_ordered_start(layout: ?*const skb_layout_t, selection: skb_text_selection_t) skb_text_position_t;
pub extern fn skb_layout_get_selection_ordered_end(layout: ?*const skb_layout_t, selection: skb_text_selection_t) skb_text_position_t;
pub extern fn skb_layout_get_selection_text_offset_range(layout: ?*const skb_layout_t, selection: skb_text_selection_t) skb_range_t;
pub extern fn skb_layout_get_selection_count(layout: ?*const skb_layout_t, selection: skb_text_selection_t) i32;
pub const skb_selection_rect_func_t = fn (skb_rect2_t, ?*anyopaque) callconv(.c) void;
pub extern fn skb_layout_get_selection_bounds(layout: ?*const skb_layout_t, selection: skb_text_selection_t, callback: ?*const skb_selection_rect_func_t, context: ?*anyopaque) void;
pub extern fn skb_layout_get_selection_bounds_with_offset(layout: ?*const skb_layout_t, offset_y: f32, selection: skb_text_selection_t, callback: ?*const skb_selection_rect_func_t, context: ?*anyopaque) void;
pub const struct_skb_caret_iterator_result_t = extern struct {
    text_position: skb_text_position_t = @import("std").mem.zeroes(skb_text_position_t),
    layout_run_idx: i32 = @import("std").mem.zeroes(i32),
    glyph_idx: i32 = @import("std").mem.zeroes(i32),
    cluster_idx: i32 = @import("std").mem.zeroes(i32),
    direction: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_caret_iterator_result_t = struct_skb_caret_iterator_result_t;
pub const struct_skb_caret_iterator_t = extern struct {
    layout: ?*const skb_layout_t = @import("std").mem.zeroes(?*const skb_layout_t),
    advance: f32 = @import("std").mem.zeroes(f32),
    x: f32 = @import("std").mem.zeroes(f32),
    layout_run_idx: i32 = @import("std").mem.zeroes(i32),
    layout_run_end: i32 = @import("std").mem.zeroes(i32),
    cluster_idx: i32 = @import("std").mem.zeroes(i32),
    cluster_end: i32 = @import("std").mem.zeroes(i32),
    glyph_idx: i32 = @import("std").mem.zeroes(i32),
    grapheme_pos: i32 = @import("std").mem.zeroes(i32),
    grapheme_end: i32 = @import("std").mem.zeroes(i32),
    end_of_runs: bool = @import("std").mem.zeroes(bool),
    end_of_line: bool = @import("std").mem.zeroes(bool),
    line_first_grapheme_offset: i32 = @import("std").mem.zeroes(i32),
    line_last_grapheme_offset: i32 = @import("std").mem.zeroes(i32),
    pending_left: skb_caret_iterator_result_t = @import("std").mem.zeroes(skb_caret_iterator_result_t),
};
pub const skb_caret_iterator_t = struct_skb_caret_iterator_t;
pub extern fn skb_caret_iterator_make(layout: ?*const skb_layout_t, line_idx: i32) skb_caret_iterator_t;
pub extern fn skb_caret_iterator_next(iter: [*c]skb_caret_iterator_t, x: [*c]f32, advance: [*c]f32, left: [*c]skb_caret_iterator_result_t, right: [*c]skb_caret_iterator_result_t) bool;
pub extern fn skb_script_to_iso15924_tag(script: u8) u32;
pub extern fn skb_script_from_iso15924_tag(script_tag: u32) u8;
pub const struct_skb_rich_text_t = opaque {};
pub const skb_rich_text_t = struct_skb_rich_text_t;
pub const struct_skb_rich_text_change_t = extern struct {
    start_paragraph_idx: i32 = @import("std").mem.zeroes(i32),
    removed_paragraph_count: i32 = @import("std").mem.zeroes(i32),
    inserted_paragraph_count: i32 = @import("std").mem.zeroes(i32),
    edit_end_position: skb_text_position_t = @import("std").mem.zeroes(skb_text_position_t),
};
pub const skb_rich_text_change_t = struct_skb_rich_text_change_t;
pub extern fn skb_rich_text_create() ?*skb_rich_text_t;
pub extern fn skb_rich_text_destroy(rich_text: ?*skb_rich_text_t) void;
pub extern fn skb_rich_text_reset(rich_text: ?*skb_rich_text_t) void;
pub extern fn skb_rich_text_get_utf32_count(rich_text: ?*const skb_rich_text_t) i32;
pub extern fn skb_rich_text_get_range_utf8_count(rich_text: ?*const skb_rich_text_t, text_range: skb_range_t) i32;
pub extern fn skb_rich_text_get_range_utf8(rich_text: ?*const skb_rich_text_t, text_range: skb_range_t, utf8: [*c]u8, utf8_cap: i32) i32;
pub extern fn skb_rich_text_get_range_utf32_count(rich_text: ?*const skb_rich_text_t, text_range: skb_range_t) i32;
pub extern fn skb_rich_text_get_range_utf32(rich_text: ?*const skb_rich_text_t, text_range: skb_range_t, utf32: [*c]u32, utf32_cap: i32) i32;
pub extern fn skb_rich_text_get_paragraphs_count(text: ?*const skb_rich_text_t) i32;
pub extern fn skb_rich_text_get_paragraph_text(text: ?*const skb_rich_text_t, index: i32) ?*const skb_text_t;
pub extern fn skb_rich_text_get_paragraph_attributes(text: ?*const skb_rich_text_t, index: i32) skb_attribute_set_t;
pub extern fn skb_rich_text_get_paragraph_text_utf32_count(text: ?*const skb_rich_text_t, index: i32) i32;
pub extern fn skb_rich_text_get_paragraph_text_offset(text: ?*const skb_rich_text_t, index: i32) i32;
pub extern fn skb_rich_text_get_paragraph_version(text: ?*const skb_rich_text_t, index: i32) u32;
pub extern fn skb_rich_text_append(rich_text: ?*skb_rich_text_t, source_rich_text: ?*const skb_rich_text_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_append_range(rich_text: ?*skb_rich_text_t, source_rich_text: ?*const skb_rich_text_t, source_text_range: skb_range_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_add_paragraph(rich_text: ?*skb_rich_text_t, paragraph_attributes: skb_attribute_set_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_append_text(rich_text: ?*skb_rich_text_t, temp_alloc: ?*skb_temp_alloc_t, from_tex: ?*const skb_text_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_append_text_range(rich_text: ?*skb_rich_text_t, temp_alloc: ?*skb_temp_alloc_t, from_text: ?*const skb_text_t, from_range: skb_range_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_append_utf8(rich_text: ?*skb_rich_text_t, temp_alloc: ?*skb_temp_alloc_t, utf8: [*c]const u8, utf8_count: i32, attributes: skb_attribute_set_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_append_utf32(rich_text: ?*skb_rich_text_t, temp_alloc: ?*skb_temp_alloc_t, utf32: [*c]const u32, utf32_count: i32, attributes: skb_attribute_set_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_replace(rich_text: ?*skb_rich_text_t, text_range: skb_range_t, source_rich_text: ?*const skb_rich_text_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_replace_range(rich_text: ?*skb_rich_text_t, text_range: skb_range_t, source_rich_text: ?*const skb_rich_text_t, source_text_range: skb_range_t) skb_rich_text_change_t;
pub extern fn skb_rich_text_set_attribute(rich_text: ?*skb_rich_text_t, text_range: skb_range_t, attribute: skb_attribute_t) void;
pub extern fn skb_rich_text_clear_attribute(rich_text: ?*skb_rich_text_t, text_range: skb_range_t, attribute: skb_attribute_t) void;
pub extern fn skb_rich_text_clear_all_attributes(rich_text: ?*skb_rich_text_t, text_range: skb_range_t) void;
pub extern fn skb_rich_text_get_attribute_count(rich_text: ?*const skb_rich_text_t, text_range: skb_range_t, attribute_kind: u32) i32;
pub const skb_rich_text_remove_func_t = fn (u32, i32, i32, ?*anyopaque) callconv(.c) bool;
pub extern fn skb_rich_text_remove_if(rich_text: ?*skb_rich_text_t, filter_func: ?*const skb_rich_text_remove_func_t, context: ?*anyopaque) void;
pub const struct_skb_editor_t = opaque {};
pub const skb_editor_t = struct_skb_editor_t;
pub const skb_editor_on_change_func_t = fn (?*skb_editor_t, ?*anyopaque) callconv(.c) void;
pub const skb_editor_input_filter_func_t = fn (?*skb_editor_t, ?*skb_rich_text_t, skb_text_selection_t, ?*anyopaque) callconv(.c) void;
pub const SKB_CARET_MODE_SKRIBIDI: c_int = 0;
pub const SKB_CARET_MODE_SIMPLE: c_int = 1;
pub const skb_editor_caret_mode_t = c_uint;
pub const SKB_BEHAVIOR_DEFAULT: c_int = 0;
pub const SKB_BEHAVIOR_MACOS: c_int = 1;
pub const skb_editor_behavior_t = c_uint;
pub const struct_skb_editor_params_t = extern struct {
    font_collection: ?*skb_font_collection_t = @import("std").mem.zeroes(?*skb_font_collection_t),
    icon_collection: ?*skb_icon_collection_t = @import("std").mem.zeroes(?*skb_icon_collection_t),
    attribute_collection: ?*skb_attribute_collection_t = @import("std").mem.zeroes(?*skb_attribute_collection_t),
    editor_width: f32 = @import("std").mem.zeroes(f32),
    layout_attributes: skb_attribute_set_t = @import("std").mem.zeroes(skb_attribute_set_t),
    text_attributes: skb_attribute_set_t = @import("std").mem.zeroes(skb_attribute_set_t),
    composition_attributes: skb_attribute_set_t = @import("std").mem.zeroes(skb_attribute_set_t),
    caret_mode: skb_editor_caret_mode_t = @import("std").mem.zeroes(skb_editor_caret_mode_t),
    editor_behavior: skb_editor_behavior_t = @import("std").mem.zeroes(skb_editor_behavior_t),
    max_undo_levels: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_editor_params_t = struct_skb_editor_params_t;
pub const SKB_KEY_NONE: c_int = 0;
pub const SKB_KEY_LEFT: c_int = 1;
pub const SKB_KEY_RIGHT: c_int = 2;
pub const SKB_KEY_UP: c_int = 3;
pub const SKB_KEY_DOWN: c_int = 4;
pub const SKB_KEY_HOME: c_int = 5;
pub const SKB_KEY_END: c_int = 6;
pub const SKB_KEY_BACKSPACE: c_int = 7;
pub const SKB_KEY_DELETE: c_int = 8;
pub const SKB_KEY_ENTER: c_int = 9;
pub const skb_editor_key_t = c_uint;
pub const SKB_MOD_NONE: c_int = 0;
pub const SKB_MOD_SHIFT: c_int = 1;
pub const SKB_MOD_CONTROL: c_int = 2;
pub const SKB_MOD_OPTION: c_int = 4;
pub const SKB_MOD_COMMAND: c_int = 8;
pub const skb_editor_key_mod_t = c_uint;
pub extern fn skb_editor_create(params: [*c]const skb_editor_params_t) ?*skb_editor_t;
pub extern fn skb_editor_set_on_change_callback(editor: ?*skb_editor_t, on_change_func: ?*const skb_editor_on_change_func_t, context: ?*anyopaque) void;
pub extern fn skb_editor_set_input_filter_callback(editor: ?*skb_editor_t, filter_func: ?*const skb_editor_input_filter_func_t, context: ?*anyopaque) void;
pub extern fn skb_editor_destroy(editor: ?*skb_editor_t) void;
pub extern fn skb_editor_reset(editor: ?*skb_editor_t, params: [*c]const skb_editor_params_t) void;
pub extern fn skb_editor_set_text_utf8(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, utf8: [*c]const u8, utf8_len: i32) void;
pub extern fn skb_editor_set_text_utf32(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, utf32: [*c]const u32, utf32_len: i32) void;
pub extern fn skb_editor_set_text(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, text: ?*skb_text_t) void;
pub extern fn skb_editor_get_text_utf8_count(editor: ?*const skb_editor_t) i32;
pub extern fn skb_editor_get_text_utf8(editor: ?*const skb_editor_t, utf8: [*c]u8, utf8_cap: i32) i32;
pub extern fn skb_editor_get_text_utf32_count(editor: ?*const skb_editor_t) i32;
pub extern fn skb_editor_get_text_utf32(editor: ?*const skb_editor_t, utf32: [*c]u32, utf32_cap: i32) i32;
pub extern fn skb_editor_get_text(editor: ?*const skb_editor_t, text: ?*skb_text_t) void;
pub extern fn skb_editor_get_paragraph_count(editor: ?*skb_editor_t) i32;
pub extern fn skb_editor_get_paragraph_layout(editor: ?*skb_editor_t, index: i32) ?*const skb_layout_t;
pub extern fn skb_editor_get_paragraph_offset_y(editor: ?*skb_editor_t, index: i32) f32;
pub extern fn skb_editor_get_paragraph_text(editor: ?*skb_editor_t, index: i32) ?*const skb_text_t;
pub extern fn skb_editor_get_paragraph_text_offset(editor: ?*skb_editor_t, index: i32) i32;
pub extern fn skb_editor_get_params(editor: ?*skb_editor_t) [*c]const skb_editor_params_t;
pub extern fn skb_editor_get_line_index_at(editor: ?*const skb_editor_t, pos: skb_text_position_t) i32;
pub extern fn skb_editor_get_column_index_at(editor: ?*const skb_editor_t, pos: skb_text_position_t) i32;
pub extern fn skb_editor_get_text_offset_at(editor: ?*const skb_editor_t, pos: skb_text_position_t) i32;
pub extern fn skb_editor_get_text_direction_at(editor: ?*const skb_editor_t, pos: skb_text_position_t) skb_text_direction_t;
pub extern fn skb_editor_get_visual_caret(editor: ?*const skb_editor_t, pos: skb_text_position_t) skb_visual_caret_t;
pub extern fn skb_editor_hit_test(editor: ?*const skb_editor_t, @"type": skb_movement_type_t, hit_x: f32, hit_y: f32) skb_text_position_t;
pub extern fn skb_editor_select_all(editor: ?*skb_editor_t) void;
pub extern fn skb_editor_select_none(editor: ?*skb_editor_t) void;
pub extern fn skb_editor_select(editor: ?*skb_editor_t, selection: skb_text_selection_t) void;
pub extern fn skb_editor_get_current_selection(editor: ?*skb_editor_t) skb_text_selection_t;
pub extern fn skb_editor_get_selection_text_offset_range(editor: ?*const skb_editor_t, selection: skb_text_selection_t) skb_range_t;
pub extern fn skb_editor_get_selection_count(editor: ?*const skb_editor_t, selection: skb_text_selection_t) i32;
pub extern fn skb_editor_get_selection_bounds(editor: ?*const skb_editor_t, selection: skb_text_selection_t, callback: ?*const skb_selection_rect_func_t, context: ?*anyopaque) void;
pub extern fn skb_editor_get_selection_text_utf8_count(editor: ?*const skb_editor_t, selection: skb_text_selection_t) i32;
pub extern fn skb_editor_get_selection_text_utf8(editor: ?*const skb_editor_t, selection: skb_text_selection_t, utf8: [*c]u8, utf8_cap: i32) i32;
pub extern fn skb_editor_get_selection_text_utf32_count(editor: ?*const skb_editor_t, selection: skb_text_selection_t) i32;
pub extern fn skb_editor_get_selection_text_utf32(editor: ?*const skb_editor_t, selection: skb_text_selection_t, utf32: [*c]u32, utf32_cap: i32) i32;
pub extern fn skb_editor_get_selection_rich_text(editor: ?*const skb_editor_t, selection: skb_text_selection_t, rich_text: ?*skb_rich_text_t) void;
pub extern fn skb_editor_process_mouse_click(editor: ?*skb_editor_t, x: f32, y: f32, mods: u32, time: f64) void;
pub extern fn skb_editor_process_mouse_drag(editor: ?*skb_editor_t, x: f32, y: f32) void;
pub extern fn skb_editor_process_key_pressed(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, key: skb_editor_key_t, mods: u32) void;
pub extern fn skb_editor_insert_codepoint(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, codepoint: u32) void;
pub extern fn skb_editor_paste_utf8(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, utf8: [*c]const u8, utf8_len: i32) void;
pub extern fn skb_editor_paste_utf32(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, utf32: [*c]const u32, utf32_len: i32) void;
pub extern fn skb_editor_paste_text(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, text: ?*const skb_text_t) void;
pub extern fn skb_editor_paste_rich_text(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, rich_text: ?*const skb_rich_text_t) void;
pub extern fn skb_editor_cut(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t) void;
pub extern fn skb_editor_toggle_attribute(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, attribute: skb_attribute_t) void;
pub extern fn skb_editor_apply_attribute(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, attribute: skb_attribute_t) void;
pub extern fn skb_editor_set_attribute(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, selection: skb_text_selection_t, attribute: skb_attribute_t) void;
pub extern fn skb_editor_clear_attribute(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, selection: skb_text_selection_t, attribute: skb_attribute_t) void;
pub extern fn skb_editor_clear_all_attributes(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, selection: skb_text_selection_t) void;
pub extern fn skb_editor_get_attribute_count(editor: ?*const skb_editor_t, selection: skb_text_selection_t, attribute_kind: u32) i32;
pub extern fn skb_editor_get_active_attributes_count(editor: ?*const skb_editor_t) i32;
pub extern fn skb_editor_get_active_attributes(editor: ?*const skb_editor_t) [*c]const skb_attribute_t;
pub extern fn skb_editor_can_undo(editor: ?*skb_editor_t) bool;
pub extern fn skb_editor_undo(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t) void;
pub extern fn skb_editor_can_redo(editor: ?*skb_editor_t) bool;
pub extern fn skb_editor_redo(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t) void;
pub extern fn skb_editor_set_composition_utf32(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, utf32: [*c]const u32, utf32_len: i32, caret_position: i32) void;
pub extern fn skb_editor_commit_composition_utf32(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t, utf32: [*c]const u32, utf32_len: i32) void;
pub extern fn skb_editor_clear_composition(editor: ?*skb_editor_t, temp_alloc: ?*skb_temp_alloc_t) void;
pub const struct_skb_rasterizer_t = opaque {};
pub const skb_rasterizer_t = struct_skb_rasterizer_t;
pub const struct_skb_rasterizer_config_t = extern struct {
    on_edge_value: u8 = @import("std").mem.zeroes(u8),
    pixel_dist_scale: f32 = @import("std").mem.zeroes(f32),
};
pub const skb_rasterizer_config_t = struct_skb_rasterizer_config_t;
pub const SKB_RASTERIZE_ALPHA_MASK: c_int = 0;
pub const SKB_RASTERIZE_ALPHA_SDF: c_int = 1;
pub const skb_rasterize_alpha_mode_t = c_uint;
pub extern fn skb_rasterizer_create(config: [*c]skb_rasterizer_config_t) ?*skb_rasterizer_t;
pub extern fn skb_rasterizer_get_default_config() skb_rasterizer_config_t;
pub extern fn skb_rasterizer_get_config(rasterizer: ?*const skb_rasterizer_t) skb_rasterizer_config_t;
pub extern fn skb_rasterizer_destroy(rasterizer: ?*skb_rasterizer_t) void;
pub extern fn skb_rasterizer_get_glyph_dimensions(glyph_id: u32, font: ?*const skb_font_t, font_size: f32, padding: i32) skb_rect2i_t;
pub extern fn skb_rasterizer_draw_alpha_glyph(rasterizer: ?*skb_rasterizer_t, temp_alloc: ?*skb_temp_alloc_t, glyph_id: u32, font: ?*const skb_font_t, font_size: f32, alpha_mode: skb_rasterize_alpha_mode_t, offset_x: f32, offset_y: f32, target: [*c]skb_image_t) bool;
pub extern fn skb_rasterizer_draw_color_glyph(rasterizer: ?*skb_rasterizer_t, temp_alloc: ?*skb_temp_alloc_t, glyph_id: u32, font: ?*const skb_font_t, font_size: f32, alpha_mode: skb_rasterize_alpha_mode_t, offset_x: i32, offset_y: i32, target: [*c]skb_image_t) bool;
pub extern fn skb_rasterizer_get_icon_dimensions(icon: ?*const skb_icon_t, icon_scale: skb_vec2_t, padding: i32) skb_rect2i_t;
pub extern fn skb_rasterizer_draw_alpha_icon(rasterizer: ?*skb_rasterizer_t, temp_alloc: ?*skb_temp_alloc_t, icon: ?*const skb_icon_t, icon_scale: skb_vec2_t, alpha_mode: skb_rasterize_alpha_mode_t, offset_x: i32, offset_y: i32, target: [*c]skb_image_t) bool;
pub extern fn skb_rasterizer_draw_color_icon(rasterizer: ?*skb_rasterizer_t, temp_alloc: ?*skb_temp_alloc_t, icon: ?*const skb_icon_t, icon_scale: skb_vec2_t, alpha_mode: skb_rasterize_alpha_mode_t, offset_x: i32, offset_y: i32, target: [*c]skb_image_t) bool;
pub extern fn skb_rasterizer_get_decoration_pattern_size(style: skb_decoration_style_t, thickness: f32) skb_vec2_t;
pub extern fn skb_rasterizer_get_decoration_pattern_dimensions(style: skb_decoration_style_t, thickness: f32, padding: i32) skb_rect2i_t;
pub extern fn skb_rasterizer_draw_decoration_pattern(rasterizer: ?*skb_rasterizer_t, temp_alloc: ?*skb_temp_alloc_t, style: skb_decoration_style_t, thickness: f32, alpha_mode: skb_rasterize_alpha_mode_t, offset_x: i32, offset_y: i32, target: [*c]skb_image_t) bool;
pub const struct_skb_image_atlas_t = opaque {};
pub const skb_image_atlas_t = struct_skb_image_atlas_t;
pub const SKB_QUAD_IS_COLOR: c_int = 1;
pub const SKB_QUAD_IS_SDF: c_int = 2;
pub const enum_skb_quad_flags_t = c_uint;
pub const struct_skb_quad_t = extern struct {
    geom: skb_rect2_t = @import("std").mem.zeroes(skb_rect2_t),
    pattern: skb_rect2_t = @import("std").mem.zeroes(skb_rect2_t),
    texture: skb_rect2_t = @import("std").mem.zeroes(skb_rect2_t),
    scale: f32 = @import("std").mem.zeroes(f32),
    color: skb_color_t = @import("std").mem.zeroes(skb_color_t),
    texture_idx: u8 = @import("std").mem.zeroes(u8),
    flags: u8 = @import("std").mem.zeroes(u8),
};
pub const skb_quad_t = struct_skb_quad_t;
pub const skb_create_texture_func_t = fn (?*skb_image_atlas_t, u8, ?*anyopaque) callconv(.c) void;
pub const struct_skb_image_item_config_t = extern struct {
    rounding: f32 = @import("std").mem.zeroes(f32),
    min_size: f32 = @import("std").mem.zeroes(f32),
    max_size: f32 = @import("std").mem.zeroes(f32),
    padding: i32 = @import("std").mem.zeroes(i32),
};
pub const skb_image_item_config_t = struct_skb_image_item_config_t;
pub const SKB_IMAGE_ATLAS_DEBUG_CLEAR_REMOVED: c_int = 1;
pub const enum_skb_image_atlas_config_flags_t = c_uint;
pub const struct_skb_image_atlas_config_t = extern struct {
    init_width: i32 = @import("std").mem.zeroes(i32),
    init_height: i32 = @import("std").mem.zeroes(i32),
    expand_size: i32 = @import("std").mem.zeroes(i32),
    max_width: i32 = @import("std").mem.zeroes(i32),
    max_height: i32 = @import("std").mem.zeroes(i32),
    item_height_rounding: i32 = @import("std").mem.zeroes(i32),
    fit_max_factor: f32 = @import("std").mem.zeroes(f32),
    evict_inactive_duration: i32 = @import("std").mem.zeroes(i32),
    flags: u8 = @import("std").mem.zeroes(u8),
    glyph_sdf: skb_image_item_config_t = @import("std").mem.zeroes(skb_image_item_config_t),
    glyph_alpha: skb_image_item_config_t = @import("std").mem.zeroes(skb_image_item_config_t),
    icon_sdf: skb_image_item_config_t = @import("std").mem.zeroes(skb_image_item_config_t),
    icon_alpha: skb_image_item_config_t = @import("std").mem.zeroes(skb_image_item_config_t),
    pattern_sdf: skb_image_item_config_t = @import("std").mem.zeroes(skb_image_item_config_t),
    pattern_alpha: skb_image_item_config_t = @import("std").mem.zeroes(skb_image_item_config_t),
};
pub const skb_image_atlas_config_t = struct_skb_image_atlas_config_t;
pub extern fn skb_image_atlas_create(config: [*c]const skb_image_atlas_config_t) ?*skb_image_atlas_t;
pub extern fn skb_image_atlas_destroy(atlas: ?*skb_image_atlas_t) void;
pub extern fn skb_image_atlas_get_default_config() skb_image_atlas_config_t;
pub extern fn skb_image_atlas_get_config(atlas: ?*skb_image_atlas_t) skb_image_atlas_config_t;
pub extern fn skb_image_atlas_set_create_texture_callback(atlas: ?*skb_image_atlas_t, create_texture_callback: ?*const skb_create_texture_func_t, context: ?*anyopaque) void;
pub extern fn skb_image_atlas_get_texture_count(atlas: ?*skb_image_atlas_t) i32;
pub extern fn skb_image_atlas_get_texture(atlas: ?*skb_image_atlas_t, texture_idx: i32) [*c]const skb_image_t;
pub extern fn skb_image_atlas_get_texture_dirty_bounds(atlas: ?*skb_image_atlas_t, texture_idx: i32) skb_rect2i_t;
pub extern fn skb_image_atlas_get_and_reset_texture_dirty_bounds(atlas: ?*skb_image_atlas_t, texture_idx: i32) skb_rect2i_t;
pub extern fn skb_image_atlas_set_texture_user_data(atlas: ?*skb_image_atlas_t, texture_idx: i32, user_data: usize) void;
pub extern fn skb_image_atlas_get_texture_user_data(image_atlas: ?*skb_image_atlas_t, texture_idx: i32) usize;
pub const skb_debug_rect_iterator_func_t = fn (i32, i32, i32, i32, ?*anyopaque) callconv(.c) void;
pub extern fn skb_image_atlas_debug_iterate_free_rects(atlas: ?*skb_image_atlas_t, texture_idx: i32, callback: ?*const skb_debug_rect_iterator_func_t, context: ?*anyopaque) void;
pub extern fn skb_image_atlas_debug_iterate_used_rects(atlas: ?*skb_image_atlas_t, texture_idx: i32, callback: ?*const skb_debug_rect_iterator_func_t, context: ?*anyopaque) void;
pub extern fn skb_image_atlas_debug_get_texture_prev_dirty_bounds(atlas: ?*skb_image_atlas_t, texture_idx: i32) skb_rect2i_t;
pub extern fn skb_image_atlas_get_glyph_quad(atlas: ?*skb_image_atlas_t, x: f32, y: f32, pixel_scale: f32, font_collection: ?*skb_font_collection_t, font_handle: skb_font_handle_t, glyph_id: u32, font_size: f32, tint_color: skb_color_t, alpha_mode: skb_rasterize_alpha_mode_t) skb_quad_t;
pub extern fn skb_image_atlas_get_icon_quad(atlas: ?*skb_image_atlas_t, x: f32, y: f32, pixel_scale: f32, icon_collection: ?*const skb_icon_collection_t, icon_handle: skb_icon_handle_t, width: f32, height: f32, tint_color: skb_color_t, alpha_mode: skb_rasterize_alpha_mode_t) skb_quad_t;
pub extern fn skb_image_atlas_get_decoration_quad(atlas: ?*skb_image_atlas_t, x: f32, y: f32, pixel_scale: f32, position: skb_decoration_position_t, style: skb_decoration_style_t, length: f32, pattern_offset: f32, thickness: f32, tint_color: skb_color_t, alpha_mode: skb_rasterize_alpha_mode_t) skb_quad_t;
pub extern fn skb_image_atlas_compact(atlas: ?*skb_image_atlas_t) bool;
pub extern fn skb_image_atlas_rasterize_missing_items(atlas: ?*skb_image_atlas_t, temp_alloc: ?*skb_temp_alloc_t, rasterizer: ?*skb_rasterizer_t) bool;
pub const struct_skb_layout_cache_t = opaque {};
pub const skb_layout_cache_t = struct_skb_layout_cache_t;
pub extern fn skb_layout_cache_create() ?*skb_layout_cache_t;
pub extern fn skb_layout_cache_destroy(cache: ?*skb_layout_cache_t) void;
pub extern fn skb_layout_cache_get_utf8(cache: ?*skb_layout_cache_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: [*c]const u8, text_count: i32, attributes: skb_attribute_set_t) ?*const skb_layout_t;
pub extern fn skb_layout_cache_get_utf32(cache: ?*skb_layout_cache_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: [*c]const u32, text_count: i32, attributes: skb_attribute_set_t) ?*const skb_layout_t;
pub extern fn skb_layout_cache_get_from_runs(cache: ?*skb_layout_cache_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, runs: [*c]const skb_content_run_t, runs_count: i32) ?*const skb_layout_t;
pub extern fn skb_layout_cache_compact(cache: ?*skb_layout_cache_t) bool;
pub const struct_skb_rich_layout_t = opaque {};
pub const skb_rich_layout_t = struct_skb_rich_layout_t;
pub extern fn skb_rich_layout_create() ?*skb_rich_layout_t;
pub extern fn skb_rich_layout_destroy(rich_layout: ?*skb_rich_layout_t) void;
pub extern fn skb_rich_layout_reset(rich_layout: ?*skb_rich_layout_t) void;
pub extern fn skb_rich_layout_get_paragraphs_count(rich_layout: ?*const skb_rich_layout_t) i32;
pub extern fn skb_rich_layout_get_layout(rich_layout: ?*const skb_rich_layout_t, index: i32) ?*const skb_layout_t;
pub extern fn skb_rich_layout_get_layout_offset_y(rich_layout: ?*const skb_rich_layout_t, index: i32) f32;
pub extern fn skb_rich_layout_get_direction(rich_layout: ?*const skb_rich_layout_t, index: i32) skb_text_direction_t;
pub extern fn skb_rich_layout_get_params(rich_layout: ?*const skb_rich_layout_t) [*c]const skb_layout_params_t;
pub extern fn skb_rich_layout_get_bounds(rich_layout: ?*const skb_rich_layout_t) skb_rect2_t;
pub extern fn skb_rich_layout_set_from_rich_text(rich_layout: ?*skb_rich_layout_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, rich_text: ?*const skb_rich_text_t, ime_text_offset: i32, ime_text: ?*skb_text_t) void;
pub extern fn skb_rich_layout_set_from_rich_text_with_change(rich_layout: ?*skb_rich_layout_t, temp_alloc: ?*skb_temp_alloc_t, params: [*c]const skb_layout_params_t, text: ?*const skb_rich_text_t, change: skb_rich_text_change_t, ime_text_offset: i32, ime_text: ?*skb_text_t) void;
pub const SKB_AFFINITY_USE: c_int = 0;
pub const SKB_AFFINITY_IGNORE: c_int = 1;
pub const skb_affinity_usage_t = c_uint;
pub extern fn skb_rich_layout_get_paragraph_position(rich_layout: ?*const skb_rich_layout_t, text_pos: skb_text_position_t, affinity_usage: skb_affinity_usage_t) skb_paragraph_position_t;
pub extern fn skb_rich_layout_text_position_to_offset(rich_layout: ?*const skb_rich_layout_t, text_pos: skb_text_position_t) i32;
pub extern fn skb_rich_layout_text_selection_to_range(rich_layout: ?*const skb_rich_layout_t, selection: skb_text_selection_t) skb_range_t;
pub extern fn skb_rich_layout_get_visual_caret(rich_layout: ?*const skb_rich_layout_t, pos: skb_text_position_t) skb_visual_caret_t;
pub extern fn skb_rich_layout_get_selection_bounds(rich_layout: ?*const skb_rich_layout_t, selection: skb_text_selection_t, callback: ?*const skb_selection_rect_func_t, context: ?*anyopaque) void;
pub extern fn skb_rich_layout_hit_test(rich_layout: ?*const skb_rich_layout_t, @"type": skb_movement_type_t, hit_x: f32, hit_y: f32) skb_text_position_t;
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 20);
pub const __clang_minor__ = @as(c_int, 1);
pub const __clang_patchlevel__ = @as(c_int, 2);
pub const __clang_version__ = "20.1.2 (https://github.com/ziglang/zig-bootstrap c6bc9398c72c7a63fe9420a9055dcfd1845bc266)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __MEMORY_SCOPE_SYSTEM = @as(c_int, 0);
pub const __MEMORY_SCOPE_DEVICE = @as(c_int, 1);
pub const __MEMORY_SCOPE_WRKGRP = @as(c_int, 2);
pub const __MEMORY_SCOPE_WVFRNT = @as(c_int, 3);
pub const __MEMORY_SCOPE_SINGLE = @as(c_int, 4);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __FPCLASS_SNAN = @as(c_int, 0x0001);
pub const __FPCLASS_QNAN = @as(c_int, 0x0002);
pub const __FPCLASS_NEGINF = @as(c_int, 0x0004);
pub const __FPCLASS_NEGNORMAL = @as(c_int, 0x0008);
pub const __FPCLASS_NEGSUBNORMAL = @as(c_int, 0x0010);
pub const __FPCLASS_NEGZERO = @as(c_int, 0x0020);
pub const __FPCLASS_POSZERO = @as(c_int, 0x0040);
pub const __FPCLASS_POSSUBNORMAL = @as(c_int, 0x0080);
pub const __FPCLASS_POSNORMAL = @as(c_int, 0x0100);
pub const __FPCLASS_POSINF = @as(c_int, 0x0200);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 20.1.2 (https://github.com/ziglang/zig-bootstrap c6bc9398c72c7a63fe9420a9055dcfd1845bc266)";
pub const __GXX_TYPEINFO_EQUALITY_INLINE = @as(c_int, 0);
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __SEH__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-16";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 1);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 32);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 8388608, .decimal);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @as(c_long, 2147483647);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 16);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 16);
pub const __INTMAX_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 4);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 2);
pub const __SIZEOF_WINT_T__ = @as(c_int, 2);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_longlong;
pub const __INTMAX_FMTd__ = "lld";
pub const __INTMAX_FMTi__ = "lli";
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `LL`");
// (no file):95:9
pub const __INTMAX_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub const __UINTMAX_TYPE__ = c_ulonglong;
pub const __UINTMAX_FMTo__ = "llo";
pub const __UINTMAX_FMTu__ = "llu";
pub const __UINTMAX_FMTx__ = "llx";
pub const __UINTMAX_FMTX__ = "llX";
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `ULL`");
// (no file):102:9
pub const __UINTMAX_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const __PTRDIFF_TYPE__ = c_longlong;
pub const __PTRDIFF_FMTd__ = "lld";
pub const __PTRDIFF_FMTi__ = "lli";
pub const __INTPTR_TYPE__ = c_longlong;
pub const __INTPTR_FMTd__ = "lld";
pub const __INTPTR_FMTi__ = "lli";
pub const __SIZE_TYPE__ = c_ulonglong;
pub const __SIZE_FMTo__ = "llo";
pub const __SIZE_FMTu__ = "llu";
pub const __SIZE_FMTx__ = "llx";
pub const __SIZE_FMTX__ = "llX";
pub const __WCHAR_TYPE__ = c_ushort;
pub const __WINT_TYPE__ = c_ushort;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulonglong;
pub const __UINTPTR_FMTo__ = "llo";
pub const __UINTPTR_FMTu__ = "llu";
pub const __UINTPTR_FMTx__ = "llx";
pub const __UINTPTR_FMTX__ = "llX";
pub const __FLT16_DENORM_MIN__ = @as(f16, 5.9604644775390625e-8);
pub const __FLT16_NORM_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_EPSILON__ = @as(f16, 9.765625e-4);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT16_MIN__ = @as(f16, 6.103515625e-5);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_NORM_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_NORM_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_NORM_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WCHAR_UNSIGNED__ = @as(c_int, 1);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub inline fn __INT8_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub inline fn __INT16_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub inline fn __INT32_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const __INT64_TYPE__ = c_longlong;
pub const __INT64_FMTd__ = "lld";
pub const __INT64_FMTi__ = "lli";
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `LL`");
// (no file):208:9
pub const __INT64_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub inline fn __UINT8_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub inline fn __UINT16_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`");
// (no file):233:9
pub const __UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulonglong;
pub const __UINT64_FMTo__ = "llo";
pub const __UINT64_FMTu__ = "llu";
pub const __UINT64_FMTx__ = "llx";
pub const __UINT64_FMTX__ = "llX";
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `ULL`");
// (no file):242:9
pub const __UINT64_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const __UINT64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __INT64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_longlong;
pub const __INT_LEAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "lld";
pub const __INT_LEAST64_FMTi__ = "lli";
pub const __UINT_LEAST64_TYPE__ = c_ulonglong;
pub const __UINT_LEAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_LEAST64_FMTo__ = "llo";
pub const __UINT_LEAST64_FMTu__ = "llu";
pub const __UINT_LEAST64_FMTx__ = "llx";
pub const __UINT_LEAST64_FMTX__ = "llX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_longlong;
pub const __INT_FAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "lld";
pub const __INT_FAST64_FMTi__ = "lli";
pub const __UINT_FAST64_TYPE__ = c_ulonglong;
pub const __UINT_FAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_FAST64_FMTo__ = "llo";
pub const __UINT_FAST64_FMTu__ = "llu";
pub const __UINT_FAST64_FMTx__ = "llx";
pub const __UINT_FAST64_FMTX__ = "llX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __GCC_DESTRUCTIVE_SIZE = @as(c_int, 64);
pub const __GCC_CONSTRUCTIVE_SIZE = @as(c_int, 64);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):376:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):377:9
pub const __znver2 = @as(c_int, 1);
pub const __znver2__ = @as(c_int, 1);
pub const __tune_znver2__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __AES__ = @as(c_int, 1);
pub const __PCLMUL__ = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __LZCNT__ = @as(c_int, 1);
pub const __RDRND__ = @as(c_int, 1);
pub const __FSGSBASE__ = @as(c_int, 1);
pub const __BMI__ = @as(c_int, 1);
pub const __BMI2__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __PRFCHW__ = @as(c_int, 1);
pub const __RDSEED__ = @as(c_int, 1);
pub const __ADX__ = @as(c_int, 1);
pub const __MWAITX__ = @as(c_int, 1);
pub const __MOVBE__ = @as(c_int, 1);
pub const __SSE4A__ = @as(c_int, 1);
pub const __FMA__ = @as(c_int, 1);
pub const __F16C__ = @as(c_int, 1);
pub const __SHA__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __XSAVE__ = @as(c_int, 1);
pub const __XSAVEOPT__ = @as(c_int, 1);
pub const __XSAVEC__ = @as(c_int, 1);
pub const __XSAVES__ = @as(c_int, 1);
pub const __CLFLUSHOPT__ = @as(c_int, 1);
pub const __CLWB__ = @as(c_int, 1);
pub const __WBNOINVD__ = @as(c_int, 1);
pub const __CLZERO__ = @as(c_int, 1);
pub const __RDPID__ = @as(c_int, 1);
pub const __RDPRU__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __AVX2__ = @as(c_int, 1);
pub const __AVX__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const _WIN32 = @as(c_int, 1);
pub const _WIN64 = @as(c_int, 1);
pub const WIN32 = @as(c_int, 1);
pub const __WIN32 = @as(c_int, 1);
pub const __WIN32__ = @as(c_int, 1);
pub const WINNT = @as(c_int, 1);
pub const __WINNT = @as(c_int, 1);
pub const __WINNT__ = @as(c_int, 1);
pub const WIN64 = @as(c_int, 1);
pub const __WIN64 = @as(c_int, 1);
pub const __WIN64__ = @as(c_int, 1);
pub const __MINGW64__ = @as(c_int, 1);
pub const __MSVCRT__ = @as(c_int, 1);
pub const __MINGW32__ = @as(c_int, 1);
pub const __declspec = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// (no file):444:9
pub const _cdecl = @compileError("unable to translate macro: undefined identifier `__cdecl__`");
// (no file):445:9
pub const __cdecl = @compileError("unable to translate macro: undefined identifier `__cdecl__`");
// (no file):446:9
pub const _stdcall = @compileError("unable to translate macro: undefined identifier `__stdcall__`");
// (no file):447:9
pub const __stdcall = @compileError("unable to translate macro: undefined identifier `__stdcall__`");
// (no file):448:9
pub const _fastcall = @compileError("unable to translate macro: undefined identifier `__fastcall__`");
// (no file):449:9
pub const __fastcall = @compileError("unable to translate macro: undefined identifier `__fastcall__`");
// (no file):450:9
pub const _thiscall = @compileError("unable to translate macro: undefined identifier `__thiscall__`");
// (no file):451:9
pub const __thiscall = @compileError("unable to translate macro: undefined identifier `__thiscall__`");
// (no file):452:9
pub const _pascal = @compileError("unable to translate macro: undefined identifier `__pascal__`");
// (no file):453:9
pub const __pascal = @compileError("unable to translate macro: undefined identifier `__pascal__`");
// (no file):454:9
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const __STDC_EMBED_NOT_FOUND__ = @as(c_int, 0);
pub const __STDC_EMBED_FOUND__ = @as(c_int, 1);
pub const __STDC_EMBED_EMPTY__ = @as(c_int, 2);
pub const __MSVCRT_VERSION__ = @as(c_int, 0xE00);
pub const _WIN32_WINNT = @as(c_int, 0x0a00);
pub const SKB_ATTRIBUTE_COLLECTION_H = "";
pub const SKB_COMMON_H = "";
pub const __ASSERT_H_ = "";
pub const _INC_CRTDEFS = "";
pub const _INC_CORECRT = "";
pub const _INC__MINGW_H = "";
pub const _INC_CRTDEFS_MACRO = "";
pub const __MINGW64_PASTE2 = @compileError("unable to translate C expr: unexpected token '##'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:10:9
pub inline fn __MINGW64_PASTE(x: anytype, y: anytype) @TypeOf(__MINGW64_PASTE2(x, y)) {
    _ = &x;
    _ = &y;
    return __MINGW64_PASTE2(x, y);
}
pub const __STRINGIFY = @compileError("unable to translate C expr: unexpected token '#'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:13:9
pub inline fn __MINGW64_STRINGIFY(x: anytype) @TypeOf(__STRINGIFY(x)) {
    _ = &x;
    return __STRINGIFY(x);
}
pub const __MINGW64_VERSION_MAJOR = @as(c_int, 13);
pub const __MINGW64_VERSION_MINOR = @as(c_int, 0);
pub const __MINGW64_VERSION_BUGFIX = @as(c_int, 0);
pub const __MINGW64_VERSION_RC = @as(c_int, 0);
pub const __MINGW64_VERSION_STR = __MINGW64_STRINGIFY(__MINGW64_VERSION_MAJOR) ++ "." ++ __MINGW64_STRINGIFY(__MINGW64_VERSION_MINOR) ++ "." ++ __MINGW64_STRINGIFY(__MINGW64_VERSION_BUGFIX);
pub const __MINGW64_VERSION_STATE = "alpha";
pub const __MINGW32_MAJOR_VERSION = @as(c_int, 3);
pub const __MINGW32_MINOR_VERSION = @as(c_int, 11);
pub const _M_AMD64 = @as(c_int, 100);
pub const _M_X64 = @as(c_int, 100);
pub const @"_" = @as(c_int, 1);
pub const __MINGW_USE_UNDERSCORE_PREFIX = @as(c_int, 0);
pub const __MINGW_IMP_SYMBOL = @compileError("unable to translate macro: undefined identifier `__imp_`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:129:11
pub const __MINGW_IMP_LSYMBOL = @compileError("unable to translate macro: undefined identifier `__imp_`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:130:11
pub inline fn __MINGW_USYMBOL(sym: anytype) @TypeOf(sym) {
    _ = &sym;
    return sym;
}
pub inline fn __MINGW_LSYMBOL(sym: anytype) @TypeOf(__MINGW64_PASTE(@"_", sym)) {
    _ = &sym;
    return __MINGW64_PASTE(@"_", sym);
}
pub const __MINGW_ASM_CALL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:140:9
pub const __MINGW_ASM_CRT_CALL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:141:9
pub const __MINGW_EXTENSION = @compileError("unable to translate C expr: unexpected token '__extension__'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:173:13
pub const __C89_NAMELESS = __MINGW_EXTENSION;
pub const __C89_NAMELESSSTRUCTNAME = "";
pub const __C89_NAMELESSSTRUCTNAME1 = "";
pub const __C89_NAMELESSSTRUCTNAME2 = "";
pub const __C89_NAMELESSSTRUCTNAME3 = "";
pub const __C89_NAMELESSSTRUCTNAME4 = "";
pub const __C89_NAMELESSSTRUCTNAME5 = "";
pub const __C89_NAMELESSUNIONNAME = "";
pub const __C89_NAMELESSUNIONNAME1 = "";
pub const __C89_NAMELESSUNIONNAME2 = "";
pub const __C89_NAMELESSUNIONNAME3 = "";
pub const __C89_NAMELESSUNIONNAME4 = "";
pub const __C89_NAMELESSUNIONNAME5 = "";
pub const __C89_NAMELESSUNIONNAME6 = "";
pub const __C89_NAMELESSUNIONNAME7 = "";
pub const __C89_NAMELESSUNIONNAME8 = "";
pub const __GNU_EXTENSION = __MINGW_EXTENSION;
pub const __MINGW_HAVE_ANSI_C99_PRINTF = @as(c_int, 1);
pub const __MINGW_HAVE_WIDE_C99_PRINTF = @as(c_int, 1);
pub const __MINGW_HAVE_ANSI_C99_SCANF = @as(c_int, 1);
pub const __MINGW_HAVE_WIDE_C99_SCANF = @as(c_int, 1);
pub const __MINGW_POISON_NAME = @compileError("unable to translate macro: undefined identifier `_layout_has_not_been_verified_and_its_declaration_is_most_likely_incorrect`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:213:11
pub const __MSABI_LONG = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __MINGW_GCC_VERSION = ((__GNUC__ * @as(c_int, 10000)) + (__GNUC_MINOR__ * @as(c_int, 100))) + __GNUC_PATCHLEVEL__;
pub inline fn __MINGW_GNUC_PREREQ(major: anytype, minor: anytype) @TypeOf((__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor))) {
    _ = &major;
    _ = &minor;
    return (__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor));
}
pub inline fn __MINGW_MSC_PREREQ(major: anytype, minor: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &major;
    _ = &minor;
    return @as(c_int, 0);
}
pub const __MINGW_ATTRIB_DEPRECATED_STR = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:257:11
pub const __MINGW_SEC_WARN_STR = "This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation";
pub const __MINGW_MSVC2005_DEPREC_STR = "This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation";
pub const __MINGW_ATTRIB_DEPRECATED_MSVC2005 = __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_MSVC2005_DEPREC_STR);
pub const __MINGW_ATTRIB_DEPRECATED_SEC_WARN = __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_SEC_WARN_STR);
pub const __MINGW_MS_PRINTF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:281:9
pub const __MINGW_MS_SCANF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:284:9
pub const __MINGW_GNU_PRINTF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:287:9
pub const __MINGW_GNU_SCANF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:290:9
pub const __mingw_ovr = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:311:11
pub const __mingw_attribute_artificial = @compileError("unable to translate macro: undefined identifier `__artificial__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:318:11
pub const __MINGW_SELECTANY = @compileError("unable to translate macro: undefined identifier `__selectany__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_mac.h:324:9
pub const __MINGW_FORTIFY_LEVEL = @as(c_int, 0);
pub const __mingw_bos_ovr = __mingw_ovr;
pub const __MINGW_FORTIFY_VA_ARG = @as(c_int, 0);
pub const _INC_MINGW_SECAPI = "";
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = @as(c_int, 0);
pub const __MINGW_CRT_NAME_CONCAT2 = @compileError("unable to translate macro: undefined identifier `_s`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_secapi.h:41:9
pub const __CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY_0_3_ = @compileError("unable to translate C expr: unexpected token ';'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw_secapi.h:69:9
pub const __LONG32 = c_long;
pub const __MINGW_IMPORT = @compileError("unable to translate macro: undefined identifier `__dllimport__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:44:12
pub const __USE_CRTIMP = @as(c_int, 1);
pub const _CRTIMP = @compileError("unable to translate macro: undefined identifier `__dllimport__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:52:15
pub const __DECLSPEC_SUPPORTED = "";
pub const USE___UUIDOF = @as(c_int, 0);
pub const _inline = @compileError("unable to translate C expr: unexpected token '__inline'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:74:9
pub const __CRT_INLINE = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:83:11
pub const __MINGW_INTRIN_INLINE = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:90:9
pub const __CRT__NO_INLINE = @as(c_int, 1);
pub const __MINGW_CXX11_CONSTEXPR = "";
pub const __MINGW_CXX14_CONSTEXPR = "";
pub const __UNUSED_PARAM = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:118:11
pub const __restrict_arr = @compileError("unable to translate C expr: unexpected token '__restrict'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:133:10
pub const __MINGW_ATTRIB_NORETURN = @compileError("unable to translate macro: undefined identifier `__noreturn__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:149:9
pub const __MINGW_ATTRIB_CONST = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:150:9
pub const __MINGW_ATTRIB_MALLOC = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:160:9
pub const __MINGW_ATTRIB_PURE = @compileError("unable to translate macro: undefined identifier `__pure__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:161:9
pub const __MINGW_ATTRIB_NONNULL = @compileError("unable to translate macro: undefined identifier `__nonnull__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:174:9
pub const __MINGW_ATTRIB_UNUSED = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:180:9
pub const __MINGW_ATTRIB_USED = @compileError("unable to translate macro: undefined identifier `__used__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:186:9
pub const __MINGW_ATTRIB_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:187:9
pub const __MINGW_ATTRIB_DEPRECATED_MSG = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:189:9
pub const __MINGW_NOTHROW = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:204:9
pub const __MINGW_ATTRIB_NO_OPTIMIZE = "";
pub const __MINGW_PRAGMA_PARAM = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:222:9
pub const __MINGW_BROKEN_INTERFACE = @compileError("unable to translate macro: undefined identifier `message`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:225:9
pub const _UCRT = "";
pub inline fn __MINGW_UCRT_ASM_CALL(func: anytype) @TypeOf(__MINGW_ASM_CALL(func)) {
    _ = &func;
    return __MINGW_ASM_CALL(func);
}
pub const _INT128_DEFINED = "";
pub const __int8 = u8;
pub const __int16 = c_short;
pub const __int32 = c_int;
pub const __int64 = c_longlong;
pub const __ptr32 = "";
pub const __ptr64 = "";
pub const __unaligned = "";
pub const __w64 = "";
pub const __forceinline = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:290:9
pub const __nothrow = "";
pub const _INC_VADEFS = "";
pub const MINGW_SDK_INIT = "";
pub const MINGW_HAS_SECURE_API = @as(c_int, 1);
pub const __STDC_SECURE_LIB__ = @as(c_long, 200411);
pub const __GOT_SECURE_LIB__ = __STDC_SECURE_LIB__;
pub const MINGW_DDK_H = "";
pub const MINGW_HAS_DDK_H = @as(c_int, 1);
pub const _CRT_PACKING = @as(c_int, 8);
pub const __GNUC_VA_LIST = "";
pub const _VA_LIST_DEFINED = "";
pub inline fn _ADDRESSOF(v: anytype) @TypeOf(&v) {
    _ = &v;
    return &v;
}
pub const _crt_va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/vadefs.h:48:9
pub const _crt_va_arg = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/vadefs.h:49:9
pub const _crt_va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/vadefs.h:50:9
pub const _crt_va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/vadefs.h:51:9
pub const __CRT_STRINGIZE = @compileError("unable to translate C expr: unexpected token '#'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:309:9
pub inline fn _CRT_STRINGIZE(_Value: anytype) @TypeOf(__CRT_STRINGIZE(_Value)) {
    _ = &_Value;
    return __CRT_STRINGIZE(_Value);
}
pub const __CRT_WIDE = @compileError("unable to translate macro: undefined identifier `L`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:314:9
pub inline fn _CRT_WIDE(_String: anytype) @TypeOf(__CRT_WIDE(_String)) {
    _ = &_String;
    return __CRT_WIDE(_String);
}
pub const _W64 = "";
pub const _CRTIMP_NOIA64 = _CRTIMP;
pub const _CRTIMP2 = _CRTIMP;
pub const _CRTIMP_ALTERNATIVE = _CRTIMP;
pub const _CRT_ALTERNATIVE_IMPORTED = "";
pub const _MRTIMP2 = _CRTIMP;
pub const _DLL = "";
pub const _MT = "";
pub const _MCRTIMP = _CRTIMP;
pub const _CRTIMP_PURE = _CRTIMP;
pub const _PGLOBAL = "";
pub const _AGLOBAL = "";
pub const _SECURECRT_FILL_BUFFER_PATTERN = @as(c_int, 0xFD);
pub const _CRT_DEPRECATE_TEXT = @compileError("unable to translate macro: undefined identifier `deprecated`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:373:9
pub const _CRT_INSECURE_DEPRECATE_MEMORY = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:376:9
pub const _CRT_INSECURE_DEPRECATE_GLOBALS = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:380:9
pub const _CRT_MANAGED_HEAP_DEPRECATE = "";
pub const _CRT_OBSOLETE = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:388:9
pub const _CONST_RETURN = "";
pub const UNALIGNED = "";
pub const _CRT_ALIGN = @compileError("unable to translate macro: undefined identifier `__aligned__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:415:9
pub const __CRTDECL = __cdecl;
pub const _ARGMAX = @as(c_int, 100);
pub const _TRUNCATE = @import("std").zig.c_translation.cast(usize, -@as(c_int, 1));
pub inline fn _CRT_UNUSED(x: anytype) anyopaque {
    _ = &x;
    return @import("std").zig.c_translation.cast(anyopaque, x);
}
pub const __USE_MINGW_ANSI_STDIO = @as(c_int, 0);
pub const _CRT_glob = @compileError("unable to translate macro: undefined identifier `_dowildcard`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:479:9
pub const __ANONYMOUS_DEFINED = "";
pub const _ANONYMOUS_UNION = __MINGW_EXTENSION;
pub const _ANONYMOUS_STRUCT = __MINGW_EXTENSION;
pub const _UNION_NAME = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:499:9
pub const _STRUCT_NAME = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:500:9
pub const DUMMYUNIONNAME = "";
pub const DUMMYUNIONNAME1 = "";
pub const DUMMYUNIONNAME2 = "";
pub const DUMMYUNIONNAME3 = "";
pub const DUMMYUNIONNAME4 = "";
pub const DUMMYUNIONNAME5 = "";
pub const DUMMYUNIONNAME6 = "";
pub const DUMMYUNIONNAME7 = "";
pub const DUMMYUNIONNAME8 = "";
pub const DUMMYUNIONNAME9 = "";
pub const DUMMYSTRUCTNAME = "";
pub const DUMMYSTRUCTNAME1 = "";
pub const DUMMYSTRUCTNAME2 = "";
pub const DUMMYSTRUCTNAME3 = "";
pub const DUMMYSTRUCTNAME4 = "";
pub const DUMMYSTRUCTNAME5 = "";
pub const __CRT_UUID_DECL = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:587:9
pub const __MINGW_DEBUGBREAK_IMPL = !(__has_builtin(__debugbreak) != 0);
pub const __MINGW_FASTFAIL_IMPL = !(__has_builtin(__fastfail) != 0);
pub const __MINGW_PREFETCH_IMPL = @compileError("unable to translate macro: undefined identifier `__prefetch`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/_mingw.h:644:9
pub const _CRTNOALIAS = "";
pub const _CRTRESTRICT = "";
pub const _SIZE_T_DEFINED = "";
pub const _SSIZE_T_DEFINED = "";
pub const _RSIZE_T_DEFINED = "";
pub const _INTPTR_T_DEFINED = "";
pub const __intptr_t_defined = "";
pub const _UINTPTR_T_DEFINED = "";
pub const __uintptr_t_defined = "";
pub const _PTRDIFF_T_DEFINED = "";
pub const _PTRDIFF_T_ = "";
pub const _WCHAR_T_DEFINED = "";
pub const _WCTYPE_T_DEFINED = "";
pub const _WINT_T = "";
pub const _ERRCODE_DEFINED = "";
pub const _TIME32_T_DEFINED = "";
pub const _TIME64_T_DEFINED = "";
pub const _TIME_T_DEFINED = "";
pub const _CRT_SECURE_CPP_NOTHROW = @compileError("unable to translate macro: undefined identifier `throw`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:143:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:262:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:263:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:264:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:265:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:266:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:267:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:268:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:269:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:270:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:271:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:272:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:273:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:277:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:279:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:281:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:283:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:285:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:422:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:423:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:424:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:425:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:426:9
pub const _TAGLC_ID_DEFINED = "";
pub const _THREADLOCALEINFO = "";
pub const __crt_typefix = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/corecrt.h:486:9
pub const _CRT_USE_WINAPI_FAMILY_DESKTOP_APP = "";
pub const static_assert = @compileError("unable to translate C expr: unexpected token '_Static_assert'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/assert.h:38:9
pub const assert = @compileError("unable to translate macro: undefined identifier `__FILE__`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/assert.h:50:9
pub const __need_ptrdiff_t = "";
pub const __need_size_t = "";
pub const __need_wchar_t = "";
pub const __need_NULL = "";
pub const __need_max_align_t = "";
pub const __need_offsetof = "";
pub const __STDDEF_H = "";
pub const _PTRDIFF_T = "";
pub const _SIZE_T = "";
pub const _WCHAR_T = "";
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const __CLANG_MAX_ALIGN_T_DEFINED = "";
pub const offsetof = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\include/__stddef_offsetof.h:16:9
pub const __STDBOOL_H = "";
pub const __bool_true_false_are_defined = @as(c_int, 1);
pub const @"bool" = bool;
pub const @"true" = @as(c_int, 1);
pub const @"false" = @as(c_int, 0);
pub const __CLANG_STDINT_H = "";
pub const _STDINT_H = "";
pub const __need_wint_t = "";
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT64_MIN = -@as(c_longlong, 9223372036854775807) - @as(c_int, 1);
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = @as(c_longlong, 9223372036854775807);
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffffffff, .hex);
pub const UINT64_MAX = @as(c_ulonglong, 0xffffffffffffffff);
pub const INT_LEAST8_MIN = INT8_MIN;
pub const INT_LEAST16_MIN = INT16_MIN;
pub const INT_LEAST32_MIN = INT32_MIN;
pub const INT_LEAST64_MIN = INT64_MIN;
pub const INT_LEAST8_MAX = INT8_MAX;
pub const INT_LEAST16_MAX = INT16_MAX;
pub const INT_LEAST32_MAX = INT32_MAX;
pub const INT_LEAST64_MAX = INT64_MAX;
pub const UINT_LEAST8_MAX = UINT8_MAX;
pub const UINT_LEAST16_MAX = UINT16_MAX;
pub const UINT_LEAST32_MAX = UINT32_MAX;
pub const UINT_LEAST64_MAX = UINT64_MAX;
pub const INT_FAST8_MIN = INT8_MIN;
pub const INT_FAST16_MIN = INT16_MIN;
pub const INT_FAST32_MIN = INT32_MIN;
pub const INT_FAST64_MIN = INT64_MIN;
pub const INT_FAST8_MAX = INT8_MAX;
pub const INT_FAST16_MAX = INT16_MAX;
pub const INT_FAST32_MAX = INT32_MAX;
pub const INT_FAST64_MAX = INT64_MAX;
pub const UINT_FAST8_MAX = UINT8_MAX;
pub const UINT_FAST16_MAX = UINT16_MAX;
pub const UINT_FAST32_MAX = UINT32_MAX;
pub const UINT_FAST64_MAX = UINT64_MAX;
pub const INTPTR_MIN = INT64_MIN;
pub const INTPTR_MAX = INT64_MAX;
pub const UINTPTR_MAX = UINT64_MAX;
pub const INTMAX_MIN = INT64_MIN;
pub const INTMAX_MAX = INT64_MAX;
pub const UINTMAX_MAX = UINT64_MAX;
pub const PTRDIFF_MIN = INT64_MIN;
pub const PTRDIFF_MAX = INT64_MAX;
pub const SIG_ATOMIC_MIN = INT32_MIN;
pub const SIG_ATOMIC_MAX = INT32_MAX;
pub const SIZE_MAX = UINT64_MAX;
pub const WCHAR_MIN = @as(c_uint, 0);
pub const WCHAR_MAX = @as(c_uint, 0xffff);
pub const WINT_MIN = @as(c_uint, 0);
pub const WINT_MAX = @as(c_uint, 0xffff);
pub inline fn INT8_C(val: anytype) @TypeOf((INT_LEAST8_MAX - INT_LEAST8_MAX) + val) {
    _ = &val;
    return (INT_LEAST8_MAX - INT_LEAST8_MAX) + val;
}
pub inline fn INT16_C(val: anytype) @TypeOf((INT_LEAST16_MAX - INT_LEAST16_MAX) + val) {
    _ = &val;
    return (INT_LEAST16_MAX - INT_LEAST16_MAX) + val;
}
pub inline fn INT32_C(val: anytype) @TypeOf((INT_LEAST32_MAX - INT_LEAST32_MAX) + val) {
    _ = &val;
    return (INT_LEAST32_MAX - INT_LEAST32_MAX) + val;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub inline fn UINT8_C(val: anytype) @TypeOf(val) {
    _ = &val;
    return val;
}
pub inline fn UINT16_C(val: anytype) @TypeOf(val) {
    _ = &val;
    return val;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const _MATH_H_ = "";
pub const _DOMAIN = @as(c_int, 1);
pub const _SING = @as(c_int, 2);
pub const _OVERFLOW = @as(c_int, 3);
pub const _UNDERFLOW = @as(c_int, 4);
pub const _TLOSS = @as(c_int, 5);
pub const _PLOSS = @as(c_int, 6);
pub const DOMAIN = _DOMAIN;
pub const SING = _SING;
pub const OVERFLOW = _OVERFLOW;
pub const UNDERFLOW = _UNDERFLOW;
pub const TLOSS = _TLOSS;
pub const PLOSS = _PLOSS;
pub const M_E = @as(f64, 2.7182818284590452354);
pub const M_LOG2E = @as(f64, 1.4426950408889634074);
pub const M_LOG10E = @as(f64, 0.43429448190325182765);
pub const M_LN2 = @as(f64, 0.69314718055994530942);
pub const M_LN10 = @as(f64, 2.30258509299404568402);
pub const M_PI = @as(f64, 3.14159265358979323846);
pub const M_PI_2 = @as(f64, 1.57079632679489661923);
pub const M_PI_4 = @as(f64, 0.78539816339744830962);
pub const M_1_PI = @as(f64, 0.31830988618379067154);
pub const M_2_PI = @as(f64, 0.63661977236758134308);
pub const M_2_SQRTPI = @as(f64, 1.12837916709551257390);
pub const M_SQRT2 = @as(f64, 1.41421356237309504880);
pub const M_SQRT1_2 = @as(f64, 0.70710678118654752440);
pub const __MINGW_FPCLASS_DEFINED = @as(c_int, 1);
pub const _FPCLASS_SNAN = @as(c_int, 0x0001);
pub const _FPCLASS_QNAN = @as(c_int, 0x0002);
pub const _FPCLASS_NINF = @as(c_int, 0x0004);
pub const _FPCLASS_NN = @as(c_int, 0x0008);
pub const _FPCLASS_ND = @as(c_int, 0x0010);
pub const _FPCLASS_NZ = @as(c_int, 0x0020);
pub const _FPCLASS_PZ = @as(c_int, 0x0040);
pub const _FPCLASS_PD = @as(c_int, 0x0080);
pub const _FPCLASS_PN = @as(c_int, 0x0100);
pub const _FPCLASS_PINF = @as(c_int, 0x0200);
pub const __mingw_types_compatible_p = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:95:9
pub const __mingw_choose_expr = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:103:9
pub const __MINGW_SOFTMATH = "";
pub const _HUGE = __MINGW_IMP_SYMBOL(_HUGE).*;
pub const HUGE_VAL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:149:9
pub const _EXCEPTION_DEFINED = "";
pub const _CRT_ABS_DEFINED = "";
pub const _CRT_ATOF_DEFINED = "";
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const _COMPLEX_DEFINED = "";
pub const _CRT_MATHERR_DEFINED = "";
pub const _SIGN_DEFINED = "";
pub const FP_SNAN = _FPCLASS_SNAN;
pub const FP_QNAN = _FPCLASS_QNAN;
pub const FP_NINF = _FPCLASS_NINF;
pub const FP_PINF = _FPCLASS_PINF;
pub const FP_NDENORM = _FPCLASS_ND;
pub const FP_PDENORM = _FPCLASS_PD;
pub const FP_NZERO = _FPCLASS_NZ;
pub const FP_PZERO = _FPCLASS_PZ;
pub const FP_NNORM = _FPCLASS_NN;
pub const FP_PNORM = _FPCLASS_PN;
pub const HUGE_VALF = __builtin_huge_valf();
pub const HUGE_VALL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:342:9
pub const INFINITY = __builtin_inff();
pub const NAN = __builtin_nanf("");
pub const FP_NAN = @as(c_int, 0x0100);
pub const FP_NORMAL = @as(c_int, 0x0400);
pub const FP_INFINITE = FP_NAN | FP_NORMAL;
pub const FP_ZERO = @as(c_int, 0x4000);
pub const FP_SUBNORMAL = FP_NORMAL | FP_ZERO;
pub inline fn __dfp_expansion(__call: anytype, __fin: anytype, x: anytype) @TypeOf(__fin) {
    _ = &__call;
    _ = &__fin;
    _ = &x;
    return __fin;
}
pub const fpclassify = @compileError("unable to translate macro: undefined identifier `__builtin_trap`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:484:9
pub inline fn isfinite(x: anytype) @TypeOf((fpclassify(x) & FP_NAN) == @as(c_int, 0)) {
    _ = &x;
    return (fpclassify(x) & FP_NAN) == @as(c_int, 0);
}
pub inline fn isinf(x: anytype) @TypeOf(fpclassify(x) == FP_INFINITE) {
    _ = &x;
    return fpclassify(x) == FP_INFINITE;
}
pub const isnan = @compileError("unable to translate macro: undefined identifier `__builtin_trap`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:578:9
pub inline fn isnormal(x: anytype) @TypeOf(fpclassify(x) == FP_NORMAL) {
    _ = &x;
    return fpclassify(x) == FP_NORMAL;
}
pub const signbit = @compileError("unable to translate macro: undefined identifier `__builtin_trap`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:638:9
pub const FP_ILOGB0 = @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex));
pub const FP_ILOGBNAN = @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hex));
pub inline fn _nan() @TypeOf(nan("")) {
    return nan("");
}
pub inline fn _nanf() @TypeOf(nanf("")) {
    return nanf("");
}
pub inline fn _nanl() @TypeOf(nanl("")) {
    return nanl("");
}
pub const isgreater = @compileError("unable to translate macro: undefined identifier `__builtin_isgreater`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:974:9
pub const isgreaterequal = @compileError("unable to translate macro: undefined identifier `__builtin_isgreaterequal`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:975:9
pub const isless = @compileError("unable to translate macro: undefined identifier `__builtin_isless`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:976:9
pub const islessequal = @compileError("unable to translate macro: undefined identifier `__builtin_islessequal`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:977:9
pub const islessgreater = @compileError("unable to translate macro: undefined identifier `__builtin_islessgreater`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:978:9
pub const isunordered = @compileError("unable to translate macro: undefined identifier `__builtin_isunordered`");
// C:\Users\hexso\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig\x86_64-windows-0.15.1\lib\libc\include\any-windows-any/math.h:979:9
pub const _copysignl = copysignl;
pub const _hypotl = hypotl;
pub const matherr = _matherr;
pub const HUGE = _HUGE;
pub const SKB_COUNTOF = @compileError("unable to translate C expr: unexpected token '('");
// .\zig-out\include/skb_common.h:175:9
pub const SKB_UNUSED = @import("std").zig.c_translation.Macros.DISCARD;
pub const SKB_FLT_MAX = @as(f32, 3.402823466e+38);
pub const SKB_PI = @as(f32, 3.14159265);
pub const SKB_SIZE_AUTO = -@as(f32, 1);
pub inline fn SKB_TAG(c1: anytype, c2: anytype, c3: anytype, c4: anytype) @TypeOf(((((@import("std").zig.c_translation.cast(u32, c1) & @as(c_int, 0xff)) << @as(c_int, 24)) | ((@import("std").zig.c_translation.cast(u32, c2) & @as(c_int, 0xff)) << @as(c_int, 16))) | ((@import("std").zig.c_translation.cast(u32, c3) & @as(c_int, 0xff)) << @as(c_int, 8))) | (@import("std").zig.c_translation.cast(u32, c4) & @as(c_int, 0xff))) {
    _ = &c1;
    _ = &c2;
    _ = &c3;
    _ = &c4;
    return ((((@import("std").zig.c_translation.cast(u32, c1) & @as(c_int, 0xff)) << @as(c_int, 24)) | ((@import("std").zig.c_translation.cast(u32, c2) & @as(c_int, 0xff)) << @as(c_int, 16))) | ((@import("std").zig.c_translation.cast(u32, c3) & @as(c_int, 0xff)) << @as(c_int, 8))) | (@import("std").zig.c_translation.cast(u32, c4) & @as(c_int, 0xff));
}
pub inline fn SKB_TAG_STR(tag: anytype) @TypeOf(SKB_TAG(tag[@as(usize, @intCast(@as(c_int, 0)))], tag[@as(usize, @intCast(@as(c_int, 1)))], tag[@as(usize, @intCast(@as(c_int, 2)))], tag[@as(usize, @intCast(@as(c_int, 3)))])) {
    _ = &tag;
    return SKB_TAG(tag[@as(usize, @intCast(@as(c_int, 0)))], tag[@as(usize, @intCast(@as(c_int, 1)))], tag[@as(usize, @intCast(@as(c_int, 2)))], tag[@as(usize, @intCast(@as(c_int, 3)))]);
}
pub inline fn SKB_UNTAG(tag: anytype) u8 {
    _ = &tag;
    return blk: {
        _ = @import("std").zig.c_translation.cast(u8, (tag >> @as(c_int, 24)) & @as(c_int, 0xFF));
        _ = @import("std").zig.c_translation.cast(u8, (tag >> @as(c_int, 16)) & @as(c_int, 0xFF));
        _ = @import("std").zig.c_translation.cast(u8, (tag >> @as(c_int, 8)) & @as(c_int, 0xFF));
        break :blk @import("std").zig.c_translation.cast(u8, tag & @as(c_int, 0xFF));
    };
}
pub const SKB_ARRAY_RESERVE = @compileError("unable to translate macro: undefined identifier `_cap`");
// .\zig-out\include/skb_common.h:236:9
pub const SKB_TEMP_ALLOC = @compileError("unable to translate C expr: unexpected token ')'");
// .\zig-out\include/skb_common.h:1000:9
pub const SKB_TEMP_REALLOC = @compileError("unable to translate C expr: unexpected token ')'");
// .\zig-out\include/skb_common.h:1011:9
pub inline fn SKB_TEMP_FREE(temp_alloc: anytype, ptr: anytype) @TypeOf(skb_temp_alloc_free(temp_alloc, ptr)) {
    _ = &temp_alloc;
    _ = &ptr;
    return skb_temp_alloc_free(temp_alloc, ptr);
}
pub const SKB_TEMP_RESERVE = @compileError("unable to translate macro: undefined identifier `_cap`");
// .\zig-out\include/skb_common.h:1029:9
pub const SKB_ATTRIBUTES_H = "";
pub const SKB_FONT_COLLECTION_H = "";
pub const SKB_DEFAULT_EMBOLDEN_X = @import("std").zig.c_translation.MacroArithmetic.div(@as(f32, 1), @as(f32, 36));
pub const SKB_DEFAULT_EMBOLDEN_Y = @import("std").zig.c_translation.MacroArithmetic.div(@as(f32, 1), @as(f32, 72));
pub const SKB_DEFAULT_SLANT = @import("std").zig.c_translation.MacroArithmetic.div(@as(f32, 1), @as(f32, 6));
pub const SKB_ICON_COLLECTION_H = "";
pub const SKB_CANVAS_H = "";
pub inline fn SKB_ATTRIBUTE_SET_FROM_STATIC_ARRAY(array: anytype) skb_attribute_set_t {
    _ = &array;
    return @import("std").mem.zeroInit(skb_attribute_set_t, .{
        .attributes = array,
        .attributes_count = SKB_COUNTOF(array),
    });
}
pub const SKB_EDITOR_H = "";
pub const SKB_LAYOUT_H = "";
pub const SKB_TEXT_H = "";
pub const SKB_RICH_TEXT_H = "";
pub const SKB_IMAGE_ATLAS_H = "";
pub const SKB_RASTERIZER_H = "";
pub const SKB_LAYOUT_CACHE_H = "";
pub const SKB_RICH_LAYOUT_H = "";
pub const threadlocaleinfostruct = struct_threadlocaleinfostruct;
pub const threadmbcinfostruct = struct_threadmbcinfostruct;
pub const __lc_time_data = struct___lc_time_data;
pub const localeinfo_struct = struct_localeinfo_struct;
pub const tagLC_ID = struct_tagLC_ID;
pub const _exception = struct__exception;
pub const _complex = struct__complex;
pub const hb_language_impl_t = struct_hb_language_impl_t;
pub const skb_layout_params_flags_t = enum_skb_layout_params_flags_t;
pub const skb_text_prop_flags_t = enum_skb_text_prop_flags_t;
pub const skb_quad_flags_t = enum_skb_quad_flags_t;
pub const skb_image_atlas_config_flags_t = enum_skb_image_atlas_config_flags_t;
